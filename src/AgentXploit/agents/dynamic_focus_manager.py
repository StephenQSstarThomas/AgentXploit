"""
Dynamic Focus Manager for LLM-driven Analysis Focus Generation
Fully autonomous focus generation without rigid constraints
"""

from typing import Dict, List, Any, Optional
import json
from ..tools.core.llm_client import LLMClient
from .llm_focus_decision import LLMFocusDecisionMaker


class DynamicFocusManager:
    """Manages fully autonomous LLM-driven focus generation"""

    def __init__(self, llm_decision_maker: LLMFocusDecisionMaker = None):
        self.llm_decision_maker = llm_decision_maker or LLMFocusDecisionMaker()
        self.current_focus = None  # Will be generated by LLM
        self.focus_history = []
        self.dataflow_patterns = []
        self.tool_chains = []
        
    def generate_initial_focus(
        self,
        repo_name: str,
        initial_files: List[str] = None,
        analysis_goal: str = "",
        repo_structure: Dict[str, Any] = None
    ) -> Dict[str, Any]:
        """
        Generate initial focus using LLM (fully unconstrained)

        Returns:
            {
                'focus_description': str,
                'priority': int,
                'reasoning': str,
                'suggested_targets': List[str]
            }
        """
        # Prepare repository structure
        if repo_structure is None:
            repo_structure = {
                'directories': [],
                'files': initial_files or []
            }

        # Use LLM decision maker for unconstrained focus generation
        focus_result = self.llm_decision_maker.generate_initial_focus(
            repo_structure=repo_structure,
            initial_findings=[],
            analysis_goal=analysis_goal or f"Comprehensive security analysis of {repo_name}"
        )

        # Store focus
        self.current_focus = focus_result.get('focus_description', 'General security analysis')
        self.focus_history.append({
            "focus": self.current_focus,
            "reason": focus_result.get('reasoning', 'initial'),
            "timestamp": self._get_timestamp(),
            "priority": focus_result.get('priority', 50)
        })

        print(f"  [INITIAL_FOCUS] {self.current_focus} (priority: {focus_result.get('priority', 50)})")
        return focus_result
    
    def update_focus_from_discoveries(
        self,
        discoveries: Dict[str, Any],
        explored_paths: List[str] = None,
        analyzed_files: List[str] = None
    ) -> Dict[str, Any]:
        """
        Update focus based on analysis discoveries (fully LLM-driven)

        Returns:
            {
                'action': 'keep' | 'update' | 'shift',
                'focus_description': str,
                'priority': int,
                'reasoning': str
            }
        """
        # Extract patterns from discoveries
        recent_findings = discoveries.get('recent_findings', [])

        # Prepare current focus context
        current_focus_context = {
            'focus_description': self.current_focus or 'General analysis',
            'priority': self.focus_history[-1].get('priority', 50) if self.focus_history else 50
        }

        # Use LLM decision maker for unconstrained focus update
        focus_update = self.llm_decision_maker.update_focus_from_context(
            current_focus=current_focus_context,
            recent_findings=recent_findings,
            explored_paths=explored_paths or [],
            analyzed_files=analyzed_files or []
        )

        # Update focus if LLM recommends it
        if focus_update.get('action') in ['update', 'shift']:
            new_focus = focus_update.get('focus_description', self.current_focus)
            reason = focus_update.get('reasoning', 'LLM-driven focus update')
            priority = focus_update.get('priority', 50)

            self.current_focus = new_focus
            self.focus_history.append({
                "focus": self.current_focus,
                "reason": reason,
                "timestamp": self._get_timestamp(),
                "priority": priority,
                "action": focus_update.get('action')
            })

            print(f"  [FOCUS_{focus_update.get('action').upper()}] {self.current_focus} - {reason}")

        return focus_update
    
    def extract_discoveries_from_context(self, context_manager, security_findings: List[Dict]) -> Dict[str, Any]:
        """Extract discovery patterns from analysis context"""
        discoveries = {
            'tool_patterns': [],
            'dataflow_patterns': [],
            'high_risk_areas': [],
            'recent_findings': security_findings[-10:] if security_findings else []
        }
        
        # Extract patterns from security findings
        for finding in security_findings:
            # Look for agent_analysis section which contains dataflow info
            agent_analysis = finding.get('agent_analysis', {})
            
            # Extract identified tools
            identified_tools = agent_analysis.get('agent_tools', [])
            for tool in identified_tools:
                tool_name = tool.get('tool_name', 'unknown')
                tool_type = tool.get('tool_type', 'unknown')
                file_path = finding.get('file_path', '')
                pattern = f"{file_path}: {tool_name} ({tool_type})"
                discoveries['tool_patterns'].append(pattern)
            
            # Extract dataflow patterns
            dataflow_patterns = agent_analysis.get('dataflow_patterns', [])
            for flow in dataflow_patterns:
                flow_desc = flow.get('description', 'unknown flow')
                data_path = flow.get('data_path', 'unknown path')
                file_path = finding.get('file_path', '')
                pattern = f"{file_path}: {flow_desc} - {data_path}"
                discoveries['dataflow_patterns'].append(pattern)
                
            # Track high-risk areas
            risk_level = finding.get('risk_assessment', {}).get('overall_risk', '').lower()
            if risk_level in ['high', 'medium']:
                discoveries['high_risk_areas'].append(finding.get('file_path', ''))
        
        # Remove duplicates
        discoveries['tool_patterns'] = list(set(discoveries['tool_patterns']))
        discoveries['dataflow_patterns'] = list(set(discoveries['dataflow_patterns']))
        discoveries['high_risk_areas'] = list(set(discoveries['high_risk_areas']))
        
        return discoveries
    
    def get_focus_context(self) -> Dict[str, Any]:
        """Get current focus context for prompts"""
        return {
            'current_focus': self.current_focus,
            'focus_history': self.focus_history[-5:],  # Last 5 focus changes
            'focus_keywords': self._extract_keywords(self.current_focus)
        }
    
    def _extract_keywords(self, focus: str) -> List[str]:
        """Extract key words from focus for search prioritization (no constraints)"""
        if not focus:
            return []

        # Remove common words only
        common_words = {'and', 'the', 'of', 'in', 'for', 'to', 'a', 'an', 'is', 'are', 'was', 'were'}
        words = focus.lower().split()
        keywords = [w for w in words if w not in common_words and len(w) > 2]

        return keywords
    
    def _get_timestamp(self) -> str:
        """Get current timestamp"""
        from datetime import datetime
        return datetime.now().isoformat()
