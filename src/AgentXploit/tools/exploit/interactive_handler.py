"""
Interactive Handler for AgentXploit

Provides interactive task generation, user input processing, and confirmation mechanisms.
"""

import os
import json
import logging
import asyncio
import random
from typing import Dict, List, Optional, Any, Tuple
from pathlib import Path

from .user_input import (
    get_user_input_async,
    display_message_async,
    display_task_menu,
    display_options,
    confirm_task_execution_async
)

logger = logging.getLogger(__name__)


class InteractiveTaskHandler:
    """Handle interactive task generation and user input processing."""
    
    def __init__(self, target_path: str, llm_client=None):
        self.target_path = target_path
        self.llm_client = llm_client
        self.current_task = None
        self.current_commands = []
        
    async def generate_default_task(self) -> Dict[str, Any]:
        """Generate a simple default task with specific command."""
        
        # Always use the same command structure for OpenHands
        task_command = "cd /workspace && chmod +x test_run.py && python3 test_run.py --max-iterations 10"
        task_name = "OpenHands Security Analysis"
        description = "Run OpenHands agent to analyze repository for injection points"
        
        # Add timestamp for uniqueness
        from datetime import datetime
        task_id = f"task_{datetime.now().strftime('%H%M%S')}_{random.randint(100,999)}"
        
        return {
            "task_id": task_id,
            "name": task_name,
            "description": description, 
            "target_path": self.target_path,
            "task_command": task_command,
            "generated_at": datetime.now().isoformat(),
            "is_default": True
        }
    
    async def validate_custom_command(self, command: str) -> Dict[str, Any]:
        """Validate a custom command from user."""
        
        # Basic validation
        if not command or not command.strip():
            return {
                "success": False,
                "error": "Command cannot be empty"
            }
        
        # Ensure command starts with proper directory
        if not command.startswith("cd /workspace"):
            command = f"cd /workspace && {command}"
        
        return {
            "success": True,
            "validated_command": command,
            "description": "Custom command validated and prepared for execution"
        }
    
    
    async def process_user_input(self, user_input: str) -> Dict[str, Any]:
        """Process user input - simplified for command execution."""
        
        user_input = user_input.strip()
        
        if not user_input:
            return {
                "type": "empty",
                "message": "Please provide a command or type 'y' to proceed with default."
            }
        
        # Check for quit command
        if user_input.lower() in ['quit', 'q', 'exit']:
            return {
                "type": "quit",
                "message": "Exiting interactive session."
            }
        
        # Check for confirmation
        if user_input.lower() in ['y', 'yes']:
            return {
                "type": "confirm",
                "message": "Proceeding with default task."
            }
        
        # Otherwise, treat as custom command
        validation_result = await self.validate_custom_command(user_input)
        if validation_result["success"]:
            return {
                "type": "custom_command", 
                "command": validation_result["validated_command"],
                "message": f"Custom command prepared: {validation_result['validated_command']}"
            }
        else:
            return {
                "type": "error",
                "message": f"Command validation failed: {validation_result['error']}"
            }
    
    async def display_task_info(self, task: Dict[str, Any]):
        """Display simplified task information to the user."""
        
        display_task_menu()
        await display_message_async(f"Task: {task['name']}")
        await display_message_async(f"Description: {task['description']}")
        await display_message_async(f"Target: {task['target_path']}")
        await display_message_async("")
        
        # Show the specific command that will be executed
        if 'task_command' in task:
            await display_message_async(f"Command to execute: {task['task_command']}")
        
        await display_message_async("")
        await display_message_async(f"Task ID: {task['task_id']}")
        await display_message_async("")
        await display_message_async("Note: This will execute the agent and analyze trace files for injection points")
        await display_message_async("="*50)


async def start_interactive_session(target_path: str, llm_client=None) -> Dict[str, Any]:
    """Start an interactive session for exploit analysis."""
    
    handler = InteractiveTaskHandler(target_path, llm_client)
    
    # Generate and display default task
    default_task = await handler.generate_default_task()
    await handler.display_task_info(default_task)
    
    current_task = default_task
    final_commands = []
    
    while True:
        display_options()
        
        # Get user input
        user_input = await get_user_input_async("Your input: ")
        
        # Process user input
        result = await handler.process_user_input(user_input)
        
        if result["type"] == "quit":
            await display_message_async(f"{result['message']}")
            return {
                "success": False,
                "cancelled": True,
                "message": "Interactive session cancelled by user"
            }
        
        elif result["type"] == "confirm":
            # Use the default task command
            task_command = current_task.get('task_command', 'cd /workspace && chmod +x test_run.py && python3 test_run.py --max-iterations 10')
            
            await display_message_async(f"Ready to execute: {current_task['name']}")
            await display_message_async(f"Command: {task_command}")
            
            return {
                "success": True,
                "task": current_task,
                "openhands_command": task_command,
                "execution_mode": "confirmed"
            }
        
        elif result["type"] == "custom_command":
            # User provided a custom command
            custom_task = current_task.copy()
            custom_task['task_command'] = result['command']
            custom_task['name'] = "Custom OpenHands Execution"
            
            await display_message_async(f"Ready to execute custom command")
            await display_message_async(f"Command: {result['command']}")
            
            return {
                "success": True,
                "task": custom_task,
                "openhands_command": result['command'],
                "execution_mode": "custom"
            }
        
        elif result["type"] == "error":
            await display_message_async(f"{result['message']}")
            
        elif result["type"] == "empty":
            await display_message_async(f"{result['message']}")


# Remove the placeholder function as we now use user_input.py


async def confirm_trace_location(
    execution_result: Dict[str, Any],
    discovered_traces: List[str]
) -> Dict[str, Any]:
    """Confirm trace file location after task execution."""
    
    await display_message_async("\n" + "="*50)
    await display_message_async("TASK EXECUTION COMPLETED")
    await display_message_async("="*50)
    
    # Display execution summary
    if execution_result.get("success"):
        await display_message_async("Agent task executed successfully!")
    else:
        await display_message_async("Agent task execution completed with errors.")
    
    await display_message_async(f"Command: {execution_result.get('command', 'Unknown')}")
    
    # Display discovered trace files
    await display_message_async(f"\nDiscovered {len(discovered_traces)} trace files:")
    for i, trace_file in enumerate(discovered_traces[:5], 1):
        await display_message_async(f"  {i}. {trace_file}")
    
    if len(discovered_traces) > 5:
        await display_message_async(f"  ... and {len(discovered_traces) - 5} more")
    
    await display_message_async("\nTrace file confirmation:")
    await display_message_async("1. Type 'y' or 'yes' to use discovered trace files")
    await display_message_async("2. Provide a custom trace file path")
    await display_message_async("3. Type 'skip' to skip trace analysis")
    await display_message_async("4. Type 'quit' to exit")
    
    while True:
        user_input = await get_user_input_async("Your choice: ")
        user_input = user_input.strip().lower()
        
        if user_input in ['y', 'yes']:
            return {
                "success": True,
                "use_discovered": True,
                "trace_files": discovered_traces
            }
        elif user_input in ['skip', 's']:
            return {
                "success": True,
                "skip_analysis": True
            }
        elif user_input in ['quit', 'q']:
            return {
                "success": False,
                "cancelled": True
            }
        elif user_input and not user_input.startswith(('y', 'n', 's', 'q')):
            # Assume it's a custom path
            custom_path = user_input
            if os.path.exists(custom_path):
                await display_message_async(f"Custom trace file confirmed: {custom_path}")
                return {
                    "success": True,
                    "use_custom": True,
                    "trace_files": [custom_path]
                }
            else:
                await display_message_async(f"File not found: {custom_path}")
                await display_message_async("Please provide a valid file path or choose another option.")
        else:
            await display_message_async("Please enter 'y', custom path, 'skip', or 'quit'.")


# Export functions
__all__ = [
    'InteractiveTaskHandler',
    'start_interactive_session',
    'confirm_trace_location'
]