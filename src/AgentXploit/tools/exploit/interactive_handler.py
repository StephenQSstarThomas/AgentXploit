"""
Interactive Handler for AgentXploit

Provides interactive task generation, user input processing, and confirmation mechanisms.
"""

import os
import json
import logging
import asyncio
import random
from typing import Dict, List, Optional, Any, Tuple
from pathlib import Path

from .user_input import (
    get_user_input_async,
    display_message_async,
    display_task_menu,
    display_options,
    confirm_task_execution_async
)

logger = logging.getLogger(__name__)


class InteractiveTaskHandler:
    """Handle interactive task generation and user input processing."""
    
    def __init__(self, target_path: str, llm_client=None):
        self.target_path = target_path
        self.llm_client = llm_client
        self.current_task = None
        self.current_commands = []
        
    async def generate_default_task(self) -> Dict[str, Any]:
        """Generate a diverse default task that's different each time."""
        
        # Dynamic task templates with variety
        task_templates = [
            {
                "name": "Repository Security Analysis", 
                "description": "Analyze the agent repository for potential injection vulnerabilities in file processing",
                "focus_areas": ["file_operations", "user_input", "api_calls"]
            },
            {
                "name": "Input Validation Assessment",
                "description": "Examine how external input flows through the agent's decision-making process", 
                "focus_areas": ["input_sanitization", "command_injection", "data_flow"]
            },
            {
                "name": "GitHub Integration Security",
                "description": "Test for vulnerabilities in GitHub API data processing and issue handling",
                "focus_areas": ["github_api", "issue_content", "remote_data"]
            },
            {
                "name": "Tool Call Injection Detection",
                "description": "Identify points where external data can manipulate agent tool calls",
                "focus_areas": ["tool_parameters", "execution_context", "privilege_escalation"]
            },
            {
                "name": "Configuration File Analysis", 
                "description": "Analyze configuration files and environment setup for security issues",
                "focus_areas": ["config_files", "environment_vars", "secrets_exposure"]
            }
        ]
        
        # Select random task to ensure variety
        selected_task = random.choice(task_templates)
        
        # Add timestamp for uniqueness
        from datetime import datetime
        task_id = f"task_{datetime.now().strftime('%H%M%S')}_{random.randint(100,999)}"
        
        return {
            "task_id": task_id,
            "name": selected_task["name"],
            "description": selected_task["description"], 
            "target_path": self.target_path,
            "focus_areas": selected_task["focus_areas"],
            "generated_at": datetime.now().isoformat(),
            "is_default": True
        }
    
    async def read_file_and_generate_commands(self, file_path: str) -> Dict[str, Any]:
        """Read a reference file and generate commands based on its content."""
        
        try:
            # Resolve relative path
            if not os.path.isabs(file_path):
                file_path = os.path.join(self.target_path, file_path)
            
            if not os.path.exists(file_path):
                return {
                    "success": False,
                    "error": f"File not found: {file_path}"
                }
            
            # Read file content
            with open(file_path, 'r', encoding='utf-8', errors='ignore') as f:
                content = f.read()
            
            # Generate commands based on file type and content
            commands = await self._generate_commands_from_content(content, file_path)
            
            return {
                "success": True,
                "file_path": file_path,
                "content_preview": content[:500] + "..." if len(content) > 500 else content,
                "generated_commands": commands,
                "file_type": self._detect_file_type(file_path)
            }
            
        except Exception as e:
            logger.error(f"Error reading file {file_path}: {e}")
            return {
                "success": False,
                "error": str(e)
            }
    
    async def _generate_commands_from_content(self, content: str, file_path: str) -> List[str]:
        """Generate analysis commands based on file content."""
        
        commands = []
        file_type = self._detect_file_type(file_path)
        
        if file_type == "readme":
            # For README files, look for setup instructions
            commands.extend([
                f"grep -i 'docker\\|container' '{file_path}'",
                f"grep -i 'install\\|setup\\|run' '{file_path}'", 
                f"grep -i 'python\\|pip\\|requirements' '{file_path}'"
            ])
        
        elif file_type == "python":
            # For Python files, analyze for security patterns
            commands.extend([
                f"grep -n 'subprocess\\|os.system\\|exec\\|eval' '{file_path}'",
                f"grep -n 'input\\|raw_input\\|sys.argv' '{file_path}'",
                f"grep -n 'open\\|read\\|write' '{file_path}'"
            ])
        
        elif file_type == "config":
            # For config files, look for sensitive data
            commands.extend([
                f"grep -i 'key\\|token\\|secret\\|password' '{file_path}'",
                f"grep -i 'host\\|url\\|endpoint' '{file_path}'",
                f"cat '{file_path}'"
            ])
        
        elif file_type == "requirements":
            # For requirements, check dependencies
            commands.extend([
                f"cat '{file_path}'",
                f"grep -v '^#' '{file_path}' | grep -v '^$'",
                "pip list --outdated"
            ])
        
        else:
            # Generic analysis for other files
            commands.extend([
                f"file '{file_path}'",
                f"head -20 '{file_path}'",
                f"grep -i 'exploit\\|inject\\|malicious' '{file_path}'"
            ])
        
        # Add general exploration commands
        commands.extend([
            f"ls -la {os.path.dirname(file_path)}",
            f"find {self.target_path} -name '*.py' | head -10",
            f"find {self.target_path} -name 'README*' -o -name '*.md'"
        ])
        
        return commands
    
    def _detect_file_type(self, file_path: str) -> str:
        """Detect file type based on path and name."""
        
        file_path_lower = file_path.lower()
        
        if 'readme' in file_path_lower or file_path_lower.endswith('.md'):
            return "readme"
        elif file_path_lower.endswith('.py'):
            return "python"
        elif file_path_lower.endswith(('.json', '.yaml', '.yml', '.toml', '.ini')):
            return "config"
        elif 'requirements' in file_path_lower or file_path_lower.endswith('.txt'):
            return "requirements"
        else:
            return "unknown"
    
    def is_file_path(self, user_input: str) -> bool:
        """Check if user input looks like a file path."""
        
        # Common indicators of file paths
        path_indicators = [
            '/',        # Unix path separator
            '\\',       # Windows path separator  
            '.',        # File extension or current dir
            '.py',      # Python files
            '.md',      # Markdown files
            '.txt',     # Text files
            '.json',    # JSON files
            '.yaml',    # YAML files
            '.yml',     # YAML files
            'README',   # README files
            'requirements', # Requirements files
        ]
        
        # Check if input contains path indicators
        for indicator in path_indicators:
            if indicator in user_input:
                return True
        
        # Check if it's a relative path pattern
        if user_input.startswith(('./', '../', '~/')):
            return True
            
        # Check if it exists as a file (relative to target_path)
        potential_path = os.path.join(self.target_path, user_input)
        if os.path.exists(potential_path):
            return True
            
        return False
    
    async def process_user_input(self, user_input: str) -> Dict[str, Any]:
        """Process user input - detect if it's a file path or command."""
        
        user_input = user_input.strip()
        
        if not user_input:
            return {
                "type": "empty",
                "message": "Please provide a command or file path."
            }
        
        # Check for quit command
        if user_input.lower() in ['quit', 'q', 'exit']:
            return {
                "type": "quit",
                "message": "Exiting interactive session."
            }
        
        # Check for confirmation
        if user_input.lower() in ['y', 'yes']:
            return {
                "type": "confirm",
                "message": "Proceeding with current task."
            }
        
        # Check if input is a file path
        if self.is_file_path(user_input):
            result = await self.read_file_and_generate_commands(user_input)
            return {
                "type": "file",
                "file_path": user_input,
                "result": result
            }
        
        # Otherwise treat as a custom command/instruction
        return {
            "type": "command", 
            "command": user_input,
            "message": f"Custom instruction received: {user_input}"
        }
    
    async def display_task_info(self, task: Dict[str, Any]):
        """Display task information to the user."""
        
        display_task_menu()
        await display_message_async(f"Task: {task['name']}")
        await display_message_async(f"Description: {task['description']}")
        await display_message_async(f"Target: {task['target_path']}")
        await display_message_async("")
        
        await display_message_async("Focus Areas:")
        for area in task.get('focus_areas', []):
            await display_message_async(f"  - {area}")
        
        await display_message_async("")
        await display_message_async(f"Task ID: {task['task_id']}")
        await display_message_async(f"Generated: {task.get('generated_at', 'Unknown')}")
        await display_message_async("")
        await display_message_async("Note: Agent will execute target agent tasks and analyze trace files")
        await display_message_async("="*50)


async def start_interactive_session(target_path: str, llm_client=None) -> Dict[str, Any]:
    """Start an interactive session for exploit analysis."""
    
    handler = InteractiveTaskHandler(target_path, llm_client)
    
    # Generate and display default task
    default_task = await handler.generate_default_task()
    await handler.display_task_info(default_task)
    
    current_task = default_task
    final_commands = []
    
    while True:
        display_options()
        
        # Get user input
        user_input = await get_user_input_async("Your input: ")
        
        # Process user input
        result = await handler.process_user_input(user_input)
        
        if result["type"] == "quit":
            await display_message_async(f"{result['message']}")
            return {
                "success": False,
                "cancelled": True,
                "message": "Interactive session cancelled by user"
            }
        
        elif result["type"] == "confirm":
            # Generate default commands if none provided
            if not final_commands:
                final_commands = [
                    f"find {target_path} -name '*.py' | head -10",
                    f"grep -r 'subprocess\\|os.system' {target_path}",
                    f"ls -la {target_path}",
                ]
            
            # Final confirmation
            confirmed = await confirm_task_execution_async(
                current_task['name'], 
                len(final_commands)
            )
            
            if confirmed:
                await display_message_async(f"Proceeding with task: {current_task['name']}")
                return {
                    "success": True,
                    "task": current_task,
                    "commands": final_commands,
                    "execution_mode": "confirmed",
                    "requires_trace_confirmation": True  # Flag for trace confirmation step
                }
            else:
                await display_message_async("Task execution cancelled.")
                continue
        
        elif result["type"] == "file":
            file_result = result["result"]
            if file_result["success"]:
                await display_message_async(f"File read successfully: {result['file_path']}")
                await display_message_async(f"File type: {file_result['file_type']}")
                await display_message_async(f"Content preview:")
                await display_message_async(f"{file_result['content_preview']}")
                await display_message_async(f"Generated {len(file_result['generated_commands'])} commands")
                
                final_commands.extend(file_result["generated_commands"])
            else:
                await display_message_async(f"Error reading file: {file_result['error']}")
        
        elif result["type"] == "command":
            await display_message_async(f"Added custom instruction: {result['command']}")
            final_commands.append(result["command"])
        
        elif result["type"] == "empty":
            await display_message_async(f"{result['message']}")


# Remove the placeholder function as we now use user_input.py


async def confirm_trace_location(
    execution_result: Dict[str, Any],
    discovered_traces: List[str]
) -> Dict[str, Any]:
    """Confirm trace file location after task execution."""
    
    await display_message_async("\n" + "="*50)
    await display_message_async("TASK EXECUTION COMPLETED")
    await display_message_async("="*50)
    
    # Display execution summary
    if execution_result.get("success"):
        await display_message_async("Agent task executed successfully!")
    else:
        await display_message_async("Agent task execution completed with errors.")
    
    await display_message_async(f"Command: {execution_result.get('command', 'Unknown')}")
    
    # Display discovered trace files
    await display_message_async(f"\nDiscovered {len(discovered_traces)} trace files:")
    for i, trace_file in enumerate(discovered_traces[:5], 1):
        await display_message_async(f"  {i}. {trace_file}")
    
    if len(discovered_traces) > 5:
        await display_message_async(f"  ... and {len(discovered_traces) - 5} more")
    
    await display_message_async("\nTrace file confirmation:")
    await display_message_async("1. Type 'y' or 'yes' to use discovered trace files")
    await display_message_async("2. Provide a custom trace file path")
    await display_message_async("3. Type 'skip' to skip trace analysis")
    await display_message_async("4. Type 'quit' to exit")
    
    while True:
        user_input = await get_user_input_async("Your choice: ")
        user_input = user_input.strip().lower()
        
        if user_input in ['y', 'yes']:
            return {
                "success": True,
                "use_discovered": True,
                "trace_files": discovered_traces
            }
        elif user_input in ['skip', 's']:
            return {
                "success": True,
                "skip_analysis": True
            }
        elif user_input in ['quit', 'q']:
            return {
                "success": False,
                "cancelled": True
            }
        elif user_input and not user_input.startswith(('y', 'n', 's', 'q')):
            # Assume it's a custom path
            custom_path = user_input
            if os.path.exists(custom_path):
                await display_message_async(f"Custom trace file confirmed: {custom_path}")
                return {
                    "success": True,
                    "use_custom": True,
                    "trace_files": [custom_path]
                }
            else:
                await display_message_async(f"File not found: {custom_path}")
                await display_message_async("Please provide a valid file path or choose another option.")
        else:
            await display_message_async("Please enter 'y', custom path, 'skip', or 'quit'.")


# Export functions
__all__ = [
    'InteractiveTaskHandler',
    'start_interactive_session',
    'confirm_trace_location'
]