"""
Interactive Handler for AgentXploit

Provides interactive task generation, user input processing, and confirmation mechanisms.
"""

import os
import json
import logging
import asyncio
import random
from typing import Dict, List, Optional, Any, Tuple
from pathlib import Path

from .user_input import (
    get_user_input_async,
    display_message_async,
    display_task_menu,
    display_options,
    confirm_task_execution_async
)

logger = logging.getLogger(__name__)


class InteractiveTaskHandler:
    """Handle interactive task generation and user input processing."""
    
    def __init__(self, target_path: str, llm_client=None):
        self.target_path = target_path
        self.llm_client = llm_client
        self.current_task = None
        self.current_commands = []
        
    async def generate_default_task(self) -> Dict[str, Any]:
        """Generate a simple default task with specific command."""
        
        # Always use the same command structure for OpenHands
        task_command = "cd /workspace && chmod +x test_run.py && python3 test_run.py --max-iterations 10"
        task_name = "OpenHands Security Analysis"
        description = "Run OpenHands agent to analyze repository for injection points"
        
        # Add timestamp for uniqueness
        from datetime import datetime
        task_id = f"task_{datetime.now().strftime('%H%M%S')}_{random.randint(100,999)}"
        
        return {
            "task_id": task_id,
            "name": task_name,
            "description": description, 
            "target_path": self.target_path,
            "task_command": task_command,
            "generated_at": datetime.now().isoformat(),
            "is_default": True
        }
    
    async def validate_custom_command(self, command: str) -> Dict[str, Any]:
        """Validate a custom command from user."""
        
        # Basic validation
        if not command or not command.strip():
            return {
                "success": False,
                "error": "Command cannot be empty"
            }
        
        # Ensure command starts with proper directory
        if not command.startswith("cd /workspace"):
            command = f"cd /workspace && {command}"
        
        return {
            "success": True,
            "validated_command": command,
            "description": "Custom command validated and prepared for execution"
        }
    
    
    async def process_user_input(self, user_input: str) -> Dict[str, Any]:
        """Process user input - simplified for command execution."""
        
        user_input = user_input.strip()
        
        if not user_input:
            return {
                "type": "empty",
                "message": "Please provide a command or type 'y' to proceed with default."
            }
        
        # Check for quit command
        if user_input.lower() in ['quit', 'q', 'exit']:
            return {
                "type": "quit",
                "message": "Exiting interactive session."
            }
        
        # Check for confirmation
        if user_input.lower() in ['y', 'yes']:
            return {
                "type": "confirm",
                "message": "Proceeding with default task."
            }
        
        # Otherwise, treat as custom command
        validation_result = await self.validate_custom_command(user_input)
        if validation_result["success"]:
            return {
                "type": "custom_command", 
                "command": validation_result["validated_command"],
                "message": f"Custom command prepared: {validation_result['validated_command']}"
            }
        else:
            return {
                "type": "error",
                "message": f"Command validation failed: {validation_result['error']}"
            }
    
    async def display_task_info(self, task: Dict[str, Any]):
        """Display simplified task information to the user."""
        
        display_task_menu()
        await display_message_async(f"Task: {task['name']}")
        await display_message_async(f"Description: {task['description']}")
        await display_message_async(f"Target: {task['target_path']}")
        await display_message_async("")
        
        # Show the specific command that will be executed
        if 'task_command' in task:
            await display_message_async(f"Command to execute: {task['task_command']}")
        
        await display_message_async("")
        await display_message_async(f"Task ID: {task['task_id']}")
        await display_message_async("")
        await display_message_async("Note: This will execute the agent and analyze trace files for injection points")
        await display_message_async("="*50)


def is_openhands_project(target_path: str) -> bool:
    """
    Detect if target is an OpenHands project using strict pattern matching.
    """
    path_str = str(target_path).lower()

    # Check for exact patterns
    strict_patterns = [
        '/openhands',
        '\\openhands',
        'openhands/',
        'openhands\\',
        'all-hands-ai/openhands',
        'docker.all-hands.dev/all-hands-ai/openhands',
        'openhands-app',
        'openhands:',
        'runtime:',
        'sandbox_runtime'
    ]

    return any(pattern in path_str for pattern in strict_patterns)


async def start_interactive_session(target_path: str, llm_client=None) -> Dict[str, Any]:
    """Start a session for exploit analysis - auto-execute if configured, otherwise interactive."""

    # First check if this is an OpenHands project
    is_openhands = is_openhands_project(target_path)

    # Only check for DEFAULT_COMMAND_TYPE if this is an OpenHands project
    from ...config import settings

    if is_openhands and hasattr(settings, 'DEFAULT_COMMAND_TYPE') and settings.DEFAULT_COMMAND_TYPE:
        from ...enums.injection_types import CommandType

        # Map command type to actual command
        command_to_use = None
        command_source = "env_default"

        if settings.DEFAULT_COMMAND_TYPE == CommandType.CUSTOM:
            if hasattr(settings, 'CUSTOM_TASK') and settings.CUSTOM_TASK:
                command_to_use = settings.CUSTOM_TASK
                command_source = "env_custom_task"
        elif hasattr(settings, 'COMMANDS') and settings.DEFAULT_COMMAND_TYPE in settings.COMMANDS:
            command_to_use = settings.COMMANDS[settings.DEFAULT_COMMAND_TYPE]
            command_source = "env_predefined"

        if command_to_use:
            await display_message_async("\n" + "="*50)
            await display_message_async("AGENTXPLOIT AUTO-EXECUTION MODE")
            await display_message_async("="*50)
            await display_message_async(f"Found DEFAULT_COMMAND_TYPE in .env: {settings.DEFAULT_COMMAND_TYPE.value}")
            await display_message_async(f"Command: {command_to_use}")
            await display_message_async("Automatically executing configured command...")

            # Create task based on the configured command
            configured_task = {
                "task_id": f"auto_task_{command_source}",
                "name": f"Auto-configured Task ({settings.DEFAULT_COMMAND_TYPE.value})",
                "description": f"Automatically selected from DEFAULT_COMMAND_TYPE",
                "target_path": target_path,
                "task_command": command_to_use,
                "execution_mode": "auto_configured"
            }

            return {
                "success": True,
                "task": configured_task,
                "openhands_command": command_to_use,
                "execution_mode": "auto_configured"
            }

    # For non-OpenHands projects, check for Phase commands configuration
    elif not is_openhands:
        # Check for Phase configuration - only require phase2 command for auto-execution
        docker_command = getattr(settings, 'DEFAULT_DOCKER_COMMAND', None)
        phase2_command = getattr(settings, 'PHASE_2_EXECUTION_COMMAND', None)
        phase4_command = getattr(settings, 'PHASE_4_EXECUTION_COMMAND', None)
        report_path = getattr(settings, 'REPORT_PATH', None)

        if phase2_command:
            await display_message_async("\n" + "="*50)
            await display_message_async("AGENTXPLOIT NON-OPENHANDS AUTO-EXECUTION MODE")
            await display_message_async("="*50)
            await display_message_async(f"Found non-OpenHands configuration")
            if docker_command:
                await display_message_async(f"Docker Command: {docker_command}")
            await display_message_async(f"Phase 2 Command: {phase2_command}")
            if phase4_command:
                await display_message_async(f"Phase 4 Command: {phase4_command}")
            if report_path:
                await display_message_async(f"Report Path: {report_path}")
            await display_message_async("Automatically executing configured non-OpenHands workflow...")

            # Create task for non-OpenHands execution using phase2 command as the main task
            non_openhands_task = {
                "task_id": "auto_task_non_openhands",
                "name": "Auto-configured Non-OpenHands Task",
                "description": "Automatically configured non-OpenHands execution with Phase commands",
                "target_path": target_path,
                "task_command": phase2_command,  # Use phase2 command as the main execution command
                "docker_command": docker_command,
                "phase2_command": phase2_command,
                "phase4_command": phase4_command,
                "report_path": report_path,
                "execution_mode": "non_openhands_auto"
            }

            return {
                "success": True,
                "task": non_openhands_task,
                "openhands_command": phase2_command,  # For compatibility with workflow engine
                "execution_mode": "non_openhands_auto"
            }

    # If no default command type found, proceed with interactive mode
    await display_message_async("\n" + "="*50)
    await display_message_async("AGENTXPLOIT INTERACTIVE MODE")
    await display_message_async("="*50)
    await display_message_async("No default command configured in .env")
    await display_message_async(f"Target: {target_path}")
    await display_message_async("="*50)

    # Single interaction - ask for custom task
    await display_message_async("\nPlease provide your custom task/instruction:")
    user_input = await get_user_input_async("Your task: ")
    user_input = user_input.strip()

    # Handle quit or empty input
    if not user_input or user_input.lower() in ['quit', 'q', 'exit']:
        await display_message_async("Interactive session cancelled.")
        return {
            "success": False,
            "cancelled": True,
            "message": "Interactive session cancelled by user"
        }

    # Process custom task
    await display_message_async(f"Custom task received: {user_input}")
    await display_message_async("Preparing to execute custom task...")

    custom_task = {
        "task_id": f"custom_task_{user_input[:10]}",
        "name": "Custom Task",
        "description": f"User-provided custom task",
        "target_path": target_path,
        "task_command": user_input,
        "execution_mode": "custom"
    }

    return {
        "success": True,
        "task": custom_task,
        "openhands_command": user_input,
        "execution_mode": "custom"
    }


# Remove the placeholder function as we now use user_input.py


async def confirm_trace_location(
    execution_result: Dict[str, Any],
    discovered_traces: List[str]
) -> Dict[str, Any]:
    """Confirm trace file location after task execution."""
    
    await display_message_async("\n" + "="*50)
    await display_message_async("TASK EXECUTION COMPLETED")
    await display_message_async("="*50)
    
    # Display execution summary
    if execution_result.get("success"):
        await display_message_async("Agent task executed successfully!")
    else:
        await display_message_async("Agent task execution completed with errors.")
    
    await display_message_async(f"Command: {execution_result.get('command', 'Unknown')}")
    
    # Display discovered trace files
    await display_message_async(f"\nDiscovered {len(discovered_traces)} trace files:")
    for i, trace_file in enumerate(discovered_traces[:5], 1):
        await display_message_async(f"  {i}. {trace_file}")
    
    if len(discovered_traces) > 5:
        await display_message_async(f"  ... and {len(discovered_traces) - 5} more")
    
    await display_message_async("\nTrace file confirmation:")
    await display_message_async("1. Type 'y' or 'yes' to use discovered trace files")
    await display_message_async("2. Provide a custom trace file path")
    await display_message_async("3. Type 'skip' to skip trace analysis")
    await display_message_async("4. Type 'quit' to exit")

    # Single interaction - get user choice
    user_input = await get_user_input_async("Your choice: ")
    user_input = user_input.strip().lower()

    if user_input in ['y', 'yes']:
        return {
            "success": True,
            "use_discovered": True,
            "trace_files": discovered_traces
        }
    elif user_input in ['skip', 's']:
        return {
            "success": True,
            "skip_analysis": True
        }
    elif user_input in ['quit', 'q']:
        return {
            "success": False,
            "cancelled": True
        }
    elif user_input and not user_input.startswith(('y', 'n', 's', 'q')):
        # Assume it's a custom path
        custom_path = user_input
        if os.path.exists(custom_path):
            await display_message_async(f"Custom trace file confirmed: {custom_path}")
            return {
                "success": True,
                "use_custom": True,
                "trace_files": [custom_path]
            }
        else:
            await display_message_async(f"File not found: {custom_path}. Using discovered traces as fallback.")
            return {
                "success": True,
                "use_discovered": True,
                "trace_files": discovered_traces
            }
    else:
        # Default to using discovered traces if input is unclear
        await display_message_async("Using discovered trace files as default.")
        return {
            "success": True,
            "use_discovered": True,
            "trace_files": discovered_traces
        }


# Export functions
__all__ = [
    'InteractiveTaskHandler',
    'start_interactive_session',
    'confirm_trace_location'
]