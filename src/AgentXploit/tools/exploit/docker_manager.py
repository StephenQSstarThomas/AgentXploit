"""
Docker Manager - Simplified Docker Environment Setup
Reads DEFAULT_DOCKER_COMMAND from .env and executes it with variable expansion.
No LLM analysis, no README parsing, no fallbacks.
"""

import os
import asyncio
import logging
import uuid
import time
from typing import Dict, Any, Optional
from dataclasses import dataclass

logger = logging.getLogger(__name__)


@dataclass
class ContainerInfo:
    """Information about a running Docker container."""
    deployment_id: str
    container_id: str
    image: str
    created_at: float
    original_command: str


class DockerManager:
    """Manages Docker container lifecycle with simple command execution."""
    
    def __init__(self):
        self.containers: Dict[str, ContainerInfo] = {}
    
    async def setup_from_env(self) -> str:
        """
        Setup Docker container using DEFAULT_DOCKER_COMMAND from .env.
        
        Returns:
            deployment_id: Container deployment identifier
        
        """
        docker_command = os.getenv("DEFAULT_DOCKER_COMMAND")
        
        if not docker_command:
            error_msg = "DEFAULT_DOCKER_COMMAND not found in .env"
            logger.error(error_msg)
            raise
        
        logger.info(f"Found DEFAULT_DOCKER_COMMAND: {docker_command[:100]}...")
        
        # Expand environment variables in command
        expanded_command = self._expand_variables(docker_command)
        
        # Generate unique deployment ID
        timestamp = time.strftime("%m%d_%H%M%S")
        unique_suffix = uuid.uuid4().hex[:8]
        deployment_id = f"docker_{timestamp}_{unique_suffix}"
        
        # Ensure container has a name
        if '--name' not in expanded_command:
            expanded_command = self._inject_container_name(expanded_command, deployment_id)
        
        logger.info(f"Executing docker command with deployment_id: {deployment_id}")
        
        # Execute docker command
        container_id = await self._execute_docker_command(expanded_command)
        
        # Extract image name
        image = self._extract_image_name(expanded_command)
        
        # Store container info
        self.containers[deployment_id] = ContainerInfo(
            deployment_id=deployment_id,
            container_id=container_id,
            image=image,
            created_at=time.time(),
            original_command=docker_command
        )
        
        logger.info(f"Container created: {deployment_id} -> {container_id}")
        return deployment_id
    
    def _expand_variables(self, command: str) -> str:
        """Expand environment variables in command string."""
        expanded = command
        
        # Expand $UID
        if '$UID' in expanded:
            uid = os.getuid()
            expanded = expanded.replace('$UID', str(uid))
            logger.info(f"Expanded $UID to {uid}")
        
        # Expand other environment variables
        import re
        env_vars = re.findall(r'\$([A-Z_][A-Z0-9_]*)', expanded)
        for var in env_vars:
            if var in os.environ:
                expanded = expanded.replace(f'${var}', os.environ[var])
                logger.info(f"Expanded ${var}")
        
        return expanded
    
    def _inject_container_name(self, command: str, deployment_id: str) -> str:
        """Inject --name parameter if not present."""
        run_pos = command.find('docker run')
        if run_pos == -1:
            error_msg = "Command must contain 'docker run'"
            logger.error(error_msg)
            raise
        
        insert_pos = run_pos + len('docker run')
        return command[:insert_pos] + f' --name {deployment_id}' + command[insert_pos:]
    
    async def _execute_docker_command(self, command: str) -> str:
        """Execute docker command and return container ID."""
        if 'docker run' not in command:
            error_msg = "Command must contain 'docker run'"
            logger.error(error_msg)
            raise
        
        process = await asyncio.create_subprocess_shell(
            command,
            stdout=asyncio.subprocess.PIPE,
            stderr=asyncio.subprocess.PIPE,
            env=os.environ.copy()
        )
        
        stdout, stderr = await process.communicate()
        
        if process.returncode != 0:
            logger.error(f"Docker command failed: {stderr.decode().strip()}")
            raise
        
        container_id = stdout.decode().strip()
        
        # If no container ID returned, try to get from docker ps
        if not container_id:
            ps_process = await asyncio.create_subprocess_shell(
                "docker ps -l -q",
                stdout=asyncio.subprocess.PIPE,
                stderr=asyncio.subprocess.PIPE
            )
            ps_stdout, _ = await ps_process.communicate()
            container_id = ps_stdout.decode().strip()
        
        if not container_id:
            logger.error("Failed to get container ID after docker run")
            raise
        
        return container_id
    
    def _extract_image_name(self, command: str) -> str:
        """Extract image name from docker command."""
        parts = command.split()
        for i, part in enumerate(reversed(parts)):
            if ':' in part and '/' in part and not part.startswith('-'):
                return part
        return "unknown"
    
    async def execute_command(
        self,
        command: str,
        deployment_id: str,
        workspace: str = None,
        timeout: float = 300,
        live_output: bool = True,
        raise_on_failure: bool = True
    ) -> Dict[str, Any]:
        """
        Execute command in container with optional live output streaming.
        
        Args:
            command: Command to execute
            deployment_id: Container deployment ID
            workspace: Working directory for command execution
            timeout: Command timeout in seconds
            live_output: Stream output in real-time
            raise_on_failure: Raise exception if command fails (default True)
            
        Returns:
            Dict with execution results
        """
        if deployment_id not in self.containers:
            error_msg = f"Container not found: {deployment_id}"
            logger.error(error_msg)
            raise RuntimeError(error_msg)
        
        container_info = self.containers[deployment_id]
        container_id = container_info.container_id
        
        # Prepend cd if workspace specified and command doesn't already start with cd
        if workspace and not command.strip().startswith('cd '):
            command = f"cd {workspace} && {command}"
        
        # Build docker exec command (no -it to avoid interactive mode)
        # Redirect stdin from /dev/null to prevent blocking on input
        docker_exec = f"docker exec {container_id} bash -c {self._quote_command(command)} < /dev/null"
        
        logger.info(f"Executing in container: {command}")
        
        start_time = time.time()
        
        process = await asyncio.create_subprocess_shell(
            docker_exec,
            stdout=asyncio.subprocess.PIPE,
            stderr=asyncio.subprocess.PIPE
        )
        
        try:
            if live_output:
                # Stream output in real-time
                stdout_data = []
                stderr_data = []
                
                async def read_stdout():
                    while True:
                        line = await process.stdout.readline()
                        if not line:
                            break
                        decoded_line = line.decode('utf-8', errors='replace')
                        stdout_data.append(decoded_line)
                        print(decoded_line, end='', flush=True)
                
                async def read_stderr():
                    while True:
                        line = await process.stderr.readline()
                        if not line:
                            break
                        decoded_line = line.decode('utf-8', errors='replace')
                        stderr_data.append(decoded_line)
                        print(decoded_line, end='', flush=True)
                
                # Run both readers concurrently with timeout
                await asyncio.wait_for(
                    asyncio.gather(read_stdout(), read_stderr(), process.wait()),
                    timeout=timeout
                )
                
                stdout = ''.join(stdout_data)
                stderr = ''.join(stderr_data)
            else:
                # Non-streaming mode
                stdout, stderr = await asyncio.wait_for(
                    process.communicate(),
                    timeout=timeout
                )
                stdout = stdout.decode('utf-8', errors='replace')
                stderr = stderr.decode('utf-8', errors='replace')
            
            execution_time = time.time() - start_time
            
            result = {
                "success": process.returncode == 0,
                "stdout": stdout,
                "stderr": stderr,
                "return_code": process.returncode,
                "execution_time": execution_time,
                "command": command
            }
            
            if not result["success"]:
                logger.error(f"Command failed with return code {process.returncode}")
                logger.error(f"stderr: {result['stderr'][:500]}")
                if raise_on_failure:
                    raise
            
            return result
            
        except asyncio.TimeoutError:
            process.kill()
            await process.wait()
            logger.error(f"Command timed out after {timeout} seconds")
            if raise_on_failure:
                raise
            # Return partial result on timeout
            return {
                "success": False,
                "stdout": "",
                "stderr": f"Command timed out after {timeout} seconds",
                "return_code": -1,
                "execution_time": timeout,
                "command": command
            }
    
    def _quote_command(self, command: str) -> str:
        """Quote command for safe shell execution."""
        import shlex
        return shlex.quote(command)
    
    async def stop_container(self, deployment_id: str) -> None:
        """
        Stop and remove container.
        
        Raises:
            ValueError: If deployment_id not found
        """
        if deployment_id not in self.containers:
            logger.error(f"Container not found: {deployment_id}")
            raise
        
        container_info = self.containers[deployment_id]
        container_id = container_info.container_id
        
        # Stop container
        stop_cmd = f"docker stop {container_id}"
        process = await asyncio.create_subprocess_shell(
            stop_cmd,
            stdout=asyncio.subprocess.PIPE,
            stderr=asyncio.subprocess.PIPE
        )
        await process.communicate()
        
        # Remove container
        rm_cmd = f"docker rm {container_id}"
        process = await asyncio.create_subprocess_shell(
            rm_cmd,
            stdout=asyncio.subprocess.PIPE,
            stderr=asyncio.subprocess.PIPE
        )
        await process.communicate()
        
        del self.containers[deployment_id]
        logger.info(f"Container stopped and removed: {deployment_id}")
    
    def get_container_info(self, deployment_id: str) -> Optional[ContainerInfo]:
        """Get container information."""
        return self.containers.get(deployment_id)


# Global instance
_docker_manager = DockerManager()


async def setup_docker_from_env() -> str:
    """Setup Docker container from environment configuration."""
    return await _docker_manager.setup_from_env()


async def execute_container_command(
    command: str,
    deployment_id: str,
    workspace: str = None,
    timeout: float = 300,
    live_output: bool = False,
    raise_on_failure: bool = True
) -> Dict[str, Any]:
    """Execute command in container."""
    return await _docker_manager.execute_command(command, deployment_id, workspace, timeout, live_output, raise_on_failure)


async def stop_docker_container(deployment_id: str) -> None:
    """Stop and remove Docker container."""
    await _docker_manager.stop_container(deployment_id)


def get_container_info(deployment_id: str) -> Optional[ContainerInfo]:
    """Get container information."""
    return _docker_manager.get_container_info(deployment_id)

