"""
Subprocess-based Docker and Command Execution Tool

直接运行Docker命令和容器内命令，无复杂解析。
"""

import asyncio
import logging
import subprocess
import uuid
import time
import shlex
import os
from dataclasses import dataclass
from typing import Dict, List, Optional, Any, Union
from pathlib import Path

logger = logging.getLogger(__name__)


@dataclass
class ExecutionResult:
    """Result of command execution."""
    command: str
    success: bool
    stdout: str
    stderr: str
    return_code: int
    execution_time: float
    session_id: Optional[str] = None


@dataclass
class ContainerInfo:
    """Information about a running Docker container."""
    deployment_id: str
    container_id: str
    image: str
    created_at: float
    original_command: str  # 原始Docker命令
    has_rm_flag: bool  # 是否包含--rm标志


class DirectDockerRunner:
    """
    直接运行Docker命令的执行器。
    
    核心理念：
    1. 用户输入什么命令就运行什么命令
    2. 从README解析到什么命令就运行什么命令
    3. 不进行复杂的参数解析和重组
    """
    
    def __init__(self):
        self.containers: Dict[str, ContainerInfo] = {}
        logger.info("Initialized direct Docker runner")
    
    async def run_docker_command_directly(self, docker_command: str) -> str:
        """
        直接运行完整的Docker命令，正确处理环境变量展开。
        
        Args:
            docker_command: 完整的docker run命令（用户输入或README中的）
            
        Returns:
            deployment_id: 生成的部署ID用于后续操作
        """
        try:
            # 生成部署ID
            import datetime
            timestamp = datetime.datetime.now().strftime("%m%d_%H%M%S")
            deployment_id = f"direct_{timestamp}"
            
            # 预处理命令：展开环境变量
            processed_command = docker_command
            
            # 处理$UID变量
            if '$UID' in processed_command:
                uid = os.getuid()
                processed_command = processed_command.replace('$UID', str(uid))
                logger.info(f"Expanded $UID to {uid}")
            
            # 处理其他常见的环境变量
            import re
            env_vars = re.findall(r'\$([A-Z_][A-Z0-9_]*)', processed_command)
            for var in env_vars:
                if var in os.environ:
                    processed_command = processed_command.replace(f'${var}', os.environ[var])
                    logger.info(f"Expanded ${var} to {os.environ[var]}")
            
            # 检查是否有--rm标志（用于后续清理判断）
            has_rm_flag = '--rm' in processed_command
            
            # 保持原始的-it和--rm参数不变
            logger.info(f"Preserving original flags: -it and --rm as specified in command")
            logger.info(f"Container will auto-cleanup: {has_rm_flag}")
            
            logger.info(f"Original command: {docker_command}")
            logger.info(f"Processed command: {processed_command}")
            
            # 检查命令是否包含docker run
            if 'docker run' not in processed_command:
                raise ValueError("Command must contain 'docker run'")
            
            # 使用shell执行完整命令，确保环境变量正确展开
            result = await asyncio.create_subprocess_shell(
                processed_command,
                stdout=asyncio.subprocess.PIPE,
                stderr=asyncio.subprocess.PIPE,
                env=os.environ.copy()  # 传递完整的环境变量
            )
            stdout, stderr = await result.communicate()
            
            if result.returncode != 0:
                error_msg = f"Docker command failed: {stderr.decode()}"
                logger.error(error_msg)
                raise RuntimeError(error_msg)
            
            # 获取容器ID
            container_id = stdout.decode().strip()
            if not container_id:
                # 如果没有返回容器ID，尝试从docker ps获取最新的容器
                ps_result = await asyncio.create_subprocess_shell(
                    "docker ps -l -q",
                    stdout=asyncio.subprocess.PIPE,
                    stderr=asyncio.subprocess.PIPE
                )
                ps_stdout, _ = await ps_result.communicate()
                container_id = ps_stdout.decode().strip()
            
            # 尝试从命令中提取镜像名
            image = "unknown"
            try:
                # 简单提取最后一个看起来像镜像名的部分
                parts = processed_command.split()
                for part in reversed(parts):
                    if ':' in part and not part.startswith('-') and '/' in part:
                        image = part
                        break
                    elif not part.startswith('-') and not '=' in part and len(part) > 3:
                        # 可能是简单的镜像名
                        if part not in ['bash', 'sh', 'tail', '/dev/null']:
                            image = part
            except:
                pass
            
            # 存储容器信息
            container_info = ContainerInfo(
                deployment_id=deployment_id,
                container_id=container_id,
                image=image,
                created_at=time.time(),
                original_command=docker_command,
                has_rm_flag=has_rm_flag
            )
            
            self.containers[deployment_id] = container_info
            
            logger.info(f"Docker command executed successfully: {deployment_id} -> {container_id}")
            logger.info(f"Detected image: {image}")
            
            return deployment_id
            
        except Exception as e:
            logger.error(f"Failed to run Docker command directly: {e}")
            raise
    
    async def execute_in_container(
        self,
        command: str,
        deployment_id: str,
        timeout: Optional[float] = None
    ) -> ExecutionResult:
        """
        在指定容器中执行命令。
        
        Args:
            command: 要执行的命令
            deployment_id: 容器部署ID
            timeout: 超时时间
            
        Returns:
            ExecutionResult: 执行结果
        """
        start_time = time.time()
        
        try:
            if deployment_id not in self.containers:
                raise ValueError(f"Container not found: {deployment_id}")
            
            container_info = self.containers[deployment_id]
            container_id = container_info.container_id
            
            # 构建docker exec命令
            docker_exec_cmd = f"docker exec {container_id} bash -c {shlex.quote(command)}"
            
            logger.info(f"Executing in container {container_id}: {command}")
            
            # 执行命令
            process = await asyncio.create_subprocess_shell(
                docker_exec_cmd,
                stdout=asyncio.subprocess.PIPE,
                stderr=asyncio.subprocess.PIPE
            )
            
            if timeout:
                stdout, stderr = await asyncio.wait_for(
                    process.communicate(), timeout=timeout
                )
            else:
                stdout, stderr = await process.communicate()
            
            execution_time = time.time() - start_time
            success = process.returncode == 0
            
            return ExecutionResult(
                command=command,
                success=success,
                stdout=stdout.decode('utf-8', errors='replace'),
                stderr=stderr.decode('utf-8', errors='replace'),
                return_code=process.returncode or 0,
                execution_time=execution_time
            )
            
        except asyncio.TimeoutError:
            return ExecutionResult(
                command=command,
                success=False,
                stdout="",
                stderr=f"Command timed out after {timeout} seconds",
                return_code=-1,
                execution_time=time.time() - start_time
            )
        except Exception as e:
            logger.error(f"Command execution failed: {e}")
            return ExecutionResult(
                command=command,
                success=False,
                stdout="",
                stderr=str(e),
                return_code=-1,
                execution_time=time.time() - start_time
            )
    
    async def stop_container(self, deployment_id: str) -> bool:
        """
        停止并删除容器。
        如果容器有--rm标志，则容器停止时会自动清理，无需手动删除。
        
        Args:
            deployment_id: 容器部署ID
            
        Returns:
            bool: 是否成功
        """
        try:
            if deployment_id not in self.containers:
                logger.warning(f"Container not found: {deployment_id}")
                return False
            
            container_info = self.containers[deployment_id]
            container_id = container_info.container_id
            has_rm_flag = container_info.has_rm_flag
            
            if has_rm_flag:
                logger.info(f"Container has --rm flag, will auto-cleanup on stop: {deployment_id}")
                # 只需停止容器，--rm会自动删除
                stop_cmd = f"docker stop {container_id}"
                result = await asyncio.create_subprocess_shell(
                    stop_cmd,
                    stdout=asyncio.subprocess.PIPE,
                    stderr=asyncio.subprocess.PIPE
                )
                await result.communicate()
                logger.info(f"Stopped container (auto-cleanup): {deployment_id} ({container_id})")
            else:
                logger.info(f"Container has no --rm flag, manual cleanup required: {deployment_id}")
                # 停止容器
                stop_cmd = f"docker stop {container_id}"
                result = await asyncio.create_subprocess_shell(
                    stop_cmd,
                    stdout=asyncio.subprocess.PIPE,
                    stderr=asyncio.subprocess.PIPE
                )
                await result.communicate()
                
                # 手动删除容器
                rm_cmd = f"docker rm {container_id}"
                result = await asyncio.create_subprocess_shell(
                    rm_cmd,
                    stdout=asyncio.subprocess.PIPE,
                    stderr=asyncio.subprocess.PIPE
                )
                await result.communicate()
                logger.info(f"Stopped and manually removed container: {deployment_id} ({container_id})")
            
            # 从记录中删除
            del self.containers[deployment_id]
            return True
            
        except Exception as e:
            logger.error(f"Failed to stop container {deployment_id}: {e}")
            return False
    
    def get_container_info(self, deployment_id: str) -> Optional[Dict[str, Any]]:
        """获取容器信息。"""
        if deployment_id not in self.containers:
            return None
        
        info = self.containers[deployment_id]
        return {
            "deployment_id": info.deployment_id,
            "container_id": info.container_id,
            "image": info.image,
            "created_at": info.created_at,
            "original_command": info.original_command,
            "has_rm_flag": info.has_rm_flag
        }
    
    def list_containers(self) -> List[Dict[str, Any]]:
        """列出所有容器。"""
        return [
            self.get_container_info(deployment_id)
            for deployment_id in self.containers.keys()
        ]
    
    async def execute_raw_command(self, command: str) -> ExecutionResult:
        """
        直接在主机上执行命令（非容器内）。
        
        Args:
            command: 要执行的命令
            
        Returns:
            ExecutionResult: 执行结果
        """
        start_time = time.time()
        
        try:
            logger.info(f"Executing raw command: {command}")
            
            process = await asyncio.create_subprocess_shell(
                command,
                stdout=asyncio.subprocess.PIPE,
                stderr=asyncio.subprocess.PIPE
            )
            stdout, stderr = await process.communicate()
            
            execution_time = time.time() - start_time
            success = process.returncode == 0
            
            return ExecutionResult(
                command=command,
                success=success,
                stdout=stdout.decode('utf-8', errors='replace'),
                stderr=stderr.decode('utf-8', errors='replace'),
                return_code=process.returncode or 0,
                execution_time=execution_time
            )
            
        except Exception as e:
            logger.error(f"Raw command execution failed: {e}")
            return ExecutionResult(
                command=command,
                success=False,
                stdout="",
                stderr=str(e),
                return_code=-1,
                execution_time=time.time() - start_time
            )


# 全局实例
_docker_runner = DirectDockerRunner()


# 简化的API函数
async def run_docker_command(docker_command: str) -> str:
    """
    直接运行Docker命令。
    
    Args:
        docker_command: 完整的docker run命令
        
    Returns:
        str: 部署ID
    """
    return await _docker_runner.run_docker_command_directly(docker_command)


async def execute_command_in_container(
    command: str,
    deployment_id: str,
    timeout: Optional[float] = None
) -> ExecutionResult:
    """
    在容器中执行命令。
    
    Args:
        command: 要执行的命令
        deployment_id: 容器部署ID
        timeout: 超时时间
        
    Returns:
        ExecutionResult: 执行结果
    """
    return await _docker_runner.execute_in_container(command, deployment_id, timeout)


async def stop_docker_container(deployment_id: str) -> bool:
    """
    停止Docker容器。
    
    Args:
        deployment_id: 容器部署ID
        
    Returns:
        bool: 是否成功
    """
    return await _docker_runner.stop_container(deployment_id)


def get_container_status(deployment_id: str) -> Optional[Dict[str, Any]]:
    """
    获取容器状态。
    
    Args:
        deployment_id: 容器部署ID
        
    Returns:
        容器信息字典或None
    """
    return _docker_runner.get_container_info(deployment_id)


def list_running_containers() -> List[Dict[str, Any]]:
    """
    列出所有运行中的容器。
    
    Returns:
        容器信息列表
    """
    return _docker_runner.list_containers()


async def execute_raw_command(command: str) -> ExecutionResult:
    """
    在主机上直接执行命令。
    
    Args:
        command: 要执行的命令
        
    Returns:
        ExecutionResult: 执行结果
    """
    return await _docker_runner.execute_raw_command(command)


# 为了向后兼容，保留一些旧的函数名
async def create_docker_container(
    image: str = "python:3.12",
    deployment_id: Optional[str] = None
) -> str:
    """创建简单的Docker容器（向后兼容）。"""
    import datetime
    if not deployment_id:
        timestamp = datetime.datetime.now().strftime("%m%d_%H%M%S")
        deployment_id = f"simple_{timestamp}"
    docker_command = f"docker run -d --name {deployment_id} {image} tail -f /dev/null"
    return await run_docker_command(docker_command)


async def execute_container_command(
    command: Union[str, List[str]],
    deployment_id: str,
    timeout: Optional[float] = None,
    shell: bool = True
) -> ExecutionResult:
    """在容器中执行命令（向后兼容）。"""
    if isinstance(command, list):
        command = " ".join(shlex.quote(str(c)) for c in command)
    return await execute_command_in_container(command, deployment_id, timeout)


async def stop_container(deployment_id: str) -> bool:
    """停止容器（向后兼容）。"""
    return await stop_docker_container(deployment_id)


def list_containers() -> List[Dict[str, Any]]:
    """列出容器（向后兼容）。"""
    return list_running_containers()


# 其他向后兼容的函数
async def create_docker_container_with_config(config: Dict[str, Any]) -> str:
    """使用配置创建容器（简化版）。"""
    image = config.get("image", "python:3.12")
    return await create_docker_container(image)


async def create_development_container(base_image: str = "python:3.12") -> str:
    """创建开发容器（简化版）。"""
    return await create_docker_container(base_image)


async def create_container_session(deployment_id: str, session_name: str = "default") -> str:
    """创建容器会话（简化版）。"""
    # 简化版本，直接返回session名称
    return session_name


async def execute_in_container_session(
    command: str,
    session_name: str,
    deployment_id: str,
    timeout: Optional[float] = None
) -> ExecutionResult:
    """在容器会话中执行命令（简化版）。"""
    return await execute_command_in_container(command, deployment_id, timeout)