"""
Terminal Command Executor

Advanced terminal command execution system that captures LLM-generated commands
and executes them with full security controls and real-time interaction.
"""
import asyncio
import logging
import re
import time
import uuid
from dataclasses import dataclass
from typing import Dict, List, Optional, Any, Union, Tuple
import json

from .subprocess_docker import (
    create_docker_container,
    create_development_container,
    execute_container_command,
    create_container_session,
    execute_in_container_session,
    run_docker_command,
    ExecutionResult
)

# LLM-driven command security validation
async def validate_command_security_llm(command: str, llm_client=None) -> Dict[str, Any]:
    """LLM-based command security validation focusing on agent injection points"""
    try:
        if llm_client:
            # Use LLM to analyze command for injection potential
            analysis_prompt = f"""
COMMAND SECURITY ANALYSIS

Command to analyze: {command}

ANALYSIS FOCUS:
Determine if this command could be part of an agent tool call injection attack:
1. Could external user input have influenced this command?
2. Does it contain patterns that suggest injection (not rigid patterns, but contextual analysis)?
3. Could it be used to manipulate agent execution flow?
4. Is it accessing external resources that could be user-controlled?

Consider these injection vectors specifically:
- SWE-Bench GitHub issue content injection
- Tool parameter manipulation 
- File path traversal via user input
- Command execution with user-controlled parameters

RESPONSE FORMAT:
{{
    "risk_level": "low|medium|high|critical",
    "injection_potential": true/false,
    "reasoning": "detailed_analysis",
    "suggested_mitigation": "specific_advice"
}}
"""
            response = await llm_client.query(analysis_prompt)
            import json
            try:
                analysis = json.loads(response)
                return {
                    "valid": analysis.get("risk_level") in ["low", "medium"],
                    "risk_level": analysis.get("risk_level", "unknown"),
                    "injection_potential": analysis.get("injection_potential", False),
                    "reasoning": analysis.get("reasoning", ""),
                    "mitigation": analysis.get("suggested_mitigation", ""),
                    "sanitized_command": command
                }
            except json.JSONDecodeError:
                # Fallback to basic validation if LLM response isn't JSON
                return await _simple_command_validation(command)
        else:
            return await _simple_command_validation(command)
            
    except Exception as e:
        logger.warning(f"LLM command validation failed: {e}")
        return await _simple_command_validation(command)

async def _simple_command_validation(command: str) -> Dict[str, Any]:
    """Simple command validation - log potential risks but allow execution"""
    
    # Basic safety check for obviously destructive commands
    high_risk_patterns = ['rm -rf /', 'format c:', 'del /s /q c:']
    is_high_risk = any(pattern in command.lower() for pattern in high_risk_patterns)
    
    return {
        "valid": not is_high_risk,  # Only block obviously destructive commands
        "risk_level": "high" if is_high_risk else "low",
        "injection_potential": False,  # Let LLM analyze injection potential
        "reasoning": f"Command safety check: {'BLOCKED' if is_high_risk else 'ALLOWED'}",
        "mitigation": "Basic safety validation only",
        "sanitized_command": command
    }

async def create_secure_sandbox() -> str:
    """Mock secure sandbox creation"""
    return f"sandbox_{uuid.uuid4().hex[:8]}"

async def secure_execute(command: str, sandbox_id: str, timeout: int = 60) -> Dict[str, Any]:
    """Mock secure command execution"""
    return {
        "success": True,
        "stdout": f"Secure execution: {command}",
        "stderr": "",
        "exit_code": 0,
        "execution_time": 0.1
    }

logger = logging.getLogger(__name__)


@dataclass
class TerminalSession:
    """Information about an active terminal session."""
    session_id: str
    deployment_id: Optional[str]
    swerex_session_id: Optional[str]
    sandbox_id: Optional[str]
    created_at: float
    last_used: float
    command_history: List[Dict[str, Any]]
    environment_vars: Dict[str, str]
    working_directory: str
    is_active: bool


@dataclass
class CommandExecution:
    """Details about a command execution."""
    command: str
    source: str  # 'llm', 'user', 'system'
    execution_method: str  # 'swerex', 'secure', 'local'
    result: ExecutionResult
    session_id: str
    timestamp: float


class TerminalCommandExecutor:
    """
    Advanced terminal command executor with LLM command capture and execution.
    
    Features:
    - Captures commands from LLM responses automatically
    - Executes commands using SWE-Rex or secure terminal based on context
    - Maintains persistent terminal sessions with state
    - Provides real-time command execution with interactive capabilities
    - Comprehensive logging and security validation
    """
    
    def __init__(self):
        self.active_sessions: Dict[str, TerminalSession] = {}
        self.execution_history: List[CommandExecution] = []
        self.command_patterns = [
            # Common shell command patterns
            r'```(?:bash|shell|sh)\n(.*?)\n```',
            r'```\n\$ (.*?)\n```',
            r'^\$ (.+)$',
            r'# (.+)',
            # Direct command execution patterns
            r'(?:run|execute|command):\s*`([^`]+)`',
            r'(?:run|execute|command):\s*"([^"]+)"',
            r'(?:run|execute|command):\s*([^\n]+)',
            # Terminal prompt patterns
            r'root@[\w-]+:/[^#]*# (.+)',
            r'[\w-]+@[\w-]+:.*?\$ (.+)',
        ]
    
    async def create_terminal_session(
        self,
        session_type: str = "development",
        base_image: str = "python:3.12",
        enable_sandbox: bool = True,
        working_dir: str = None
    ) -> str:
        """
        Create a new terminal session with full execution capabilities.

        Args:
            session_type: Type of session ('development', 'security', 'exploit')
            base_image: Base container image
            enable_sandbox: Enable secure sandbox
            working_dir: Working directory

        Returns:
            Session ID
        """
        try:
            session_id = f"terminal_{uuid.uuid4().hex[:8]}"

            # Determine working directory if not provided
            if working_dir is None:
                try:
                    import os
                    from ...config import settings
                    working_dir = settings.PHASE4_WORKSPACE
                except:
                    working_dir = os.getenv("PHASE4_WORKSPACE", "/work")

            deployment_id = None
            container_session_id = None
            sandbox_id = None

            # Set up subprocess docker deployment using DEFAULT_DOCKER_COMMAND
            try:
                import os
                from ...config import settings
                default_docker_cmd = settings.DEFAULT_DOCKER_COMMAND
                if default_docker_cmd:
                    # Use the exact DEFAULT_DOCKER_COMMAND from .env
                    deployment_id = await run_docker_command(default_docker_cmd)
                    logger.info(f"Created container with DEFAULT_DOCKER_COMMAND: {deployment_id}")
                else:
                    print("ERROR: DEFAULT_DOCKER_COMMAND not found in .env")
                    raise ValueError("DEFAULT_DOCKER_COMMAND not found in .env")
            except Exception as e:
                print(f"ERROR: Failed to run DEFAULT_DOCKER_COMMAND: {e}")
                raise e

            # Create persistent bash session
            container_session_id = await create_container_session(deployment_id, "default")
            logger.info(f"Created container session: {container_session_id}")

            # Set up secure sandbox if enabled
            if enable_sandbox:
                sandbox_id = await create_secure_sandbox()
                logger.info(f"Created secure sandbox: {sandbox_id}")

            # Create session info
            session = TerminalSession(
                session_id=session_id,
                deployment_id=deployment_id,
                swerex_session_id=container_session_id,
                sandbox_id=sandbox_id,
                created_at=time.time(),
                last_used=time.time(),
                command_history=[],
                environment_vars={},
                working_directory=working_dir,
                is_active=True
            )
            
            self.active_sessions[session_id] = session
            
            logger.info(f"Created terminal session: {session_id} (type: {session_type})")
            return session_id
            
        except Exception as e:
            logger.error(f"Failed to create terminal session: {e}")
            raise
    
    def extract_commands_from_text(self, text: str) -> List[str]:
        """
        Extract executable commands from text using pattern matching.
        
        Args:
            text: Text to extract commands from
            
        Returns:
            List of extracted commands
        """
        commands = []
        
        try:
            for pattern in self.command_patterns:
                matches = re.findall(pattern, text, re.MULTILINE | re.DOTALL)
                for match in matches:
                    if isinstance(match, tuple):
                        command = match[0] if match else ""
                    else:
                        command = match
                    
                    command = command.strip()
                    if command and command not in commands:
                        # Basic filtering to avoid obvious non-commands
                        if not any(x in command.lower() for x in [
                            'example:', 'note:', 'warning:', 'output:', 'result:'
                        ]):
                            commands.append(command)
            
            # Additional extraction for direct command mentions
            lines = text.split('\n')
            for line in lines:
                line = line.strip()
                # Look for lines that start with common command patterns
                if line.startswith(('$ ', '# ', '> ')):
                    cmd = line[2:].strip()
                    if cmd and cmd not in commands:
                        commands.append(cmd)
            
            logger.info(f"Extracted {len(commands)} commands from text")
            return commands
            
        except Exception as e:
            logger.error(f"Command extraction error: {e}")
            return []
    
    async def execute_command_with_context(
        self,
        command: str,
        session_id: str,
        execution_method: str = "auto",
        interactive: bool = False,
        capture_output: bool = True
    ) -> CommandExecution:
        """
        Execute a command with full context and session management.
        
        Args:
            command: Command to execute
            session_id: Session ID
            execution_method: Method ('swerex', 'secure', 'auto')
            interactive: Enable interactive mode
            capture_output: Capture output
            
        Returns:
            CommandExecution with results
        """
        try:
            if session_id not in self.active_sessions:
                raise ValueError(f"Session not found: {session_id}")
            
            session = self.active_sessions[session_id]
            session.last_used = time.time()
            
            # Validate command security with LLM-driven analysis
            validation = await validate_command_security_llm(command)
            if validation.get("injection_potential"):
                logger.warning(f"Agent injection risk detected: {validation['reasoning']}")
                # Log the risk but continue execution (agent analysis purpose)
                logger.info(f"Mitigation advice: {validation.get('mitigation', 'None')}")
            command = validation.get("sanitized_command", command)
            
            # Determine execution method
            if execution_method == "auto":
                if session.swerex_session_id and session.deployment_id:
                    execution_method = "container"
                elif session.sandbox_id:
                    execution_method = "secure"
                else:
                    execution_method = "local"

            # Execute command based on method
            if execution_method == "container" and session.swerex_session_id:
                result = await execute_in_container_session(
                    command=command,
                    session_name=session.swerex_session_id,
                    deployment_id=session.deployment_id,
                    timeout=60.0
                )

                # Check if command execution failed
                if not result.success:
                    error_msg = f"ERROR: Docker exec command failed: {command}\nSTDOUT: {result.stdout}\nSTDERR: {result.stderr}\nReturn Code: {result.return_code}"
                    print(error_msg)
                    logger.error(error_msg)
                    raise RuntimeError(f"Command failed: {command}")

                exec_result = ExecutionResult(
                    command=command,
                    success=result.success,
                    stdout=result.stdout,
                    stderr=result.stderr,
                    return_code=result.return_code,
                    execution_time=result.execution_time,
                    session_id=session.swerex_session_id
                )
            
            elif execution_method == "secure" and session.sandbox_id:
                result_dict = await secure_execute(
                    command=command,
                    sandbox_id=session.sandbox_id,
                    timeout=60
                )
                exec_result = ExecutionResult(
                    command=command,
                    success=result_dict["success"],
                    stdout=result_dict["stdout"],
                    stderr=result_dict["stderr"],
                    return_code=result_dict["exit_code"],
                    execution_time=result_dict["execution_time"],
                    session_id=session.sandbox_id
                )
            
            else:
                # Local execution (limited and safe)
                exec_result = ExecutionResult(
                    command=command,
                    success=True,
                    stdout=f"Local simulation: {command}",
                    stderr="",
                    return_code=0,
                    execution_time=0.1,
                    session_id=session_id
                )
            
            # Create command execution record
            command_exec = CommandExecution(
                command=command,
                source="llm",
                execution_method=execution_method,
                result=exec_result,
                session_id=session_id,
                timestamp=time.time()
            )
            
            # Update session history
            session.command_history.append({
                "command": command,
                "result": {
                    "success": exec_result.success,
                    "stdout": exec_result.stdout,
                    "stderr": exec_result.stderr,
                    "return_code": exec_result.return_code
                },
                "timestamp": command_exec.timestamp,
                "execution_method": execution_method
            })
            
            # Store in global history
            self.execution_history.append(command_exec)
            
            logger.info(f"Executed command: {command} (method: {execution_method}, success: {exec_result.success})")
            return command_exec
            
        except Exception as e:
            error_msg = f"ERROR: Command execution failed in container: {e}"
            print(error_msg)
            logger.error(error_msg)
            raise e
    
    async def process_llm_response_for_commands(
        self,
        llm_response: str,
        session_id: str,
        auto_execute: bool = True
    ) -> List[CommandExecution]:
        """
        Process LLM response to extract and execute commands automatically.
        
        Args:
            llm_response: LLM response text
            session_id: Session ID to execute in
            auto_execute: Whether to execute extracted commands automatically
            
        Returns:
            List of CommandExecution results
        """
        try:
            # Extract commands from LLM response
            commands = self.extract_commands_from_text(llm_response)
            
            if not commands:
                logger.info("No commands extracted from LLM response")
                return []
            
            logger.info(f"Found {len(commands)} commands in LLM response")
            
            executions = []
            
            if auto_execute:
                for command in commands:
                    logger.info(f"Auto-executing command: {command}")
                    execution = await self.execute_command_with_context(
                        command=command,
                        session_id=session_id,
                        execution_method="auto",
                        capture_output=True
                    )
                    executions.append(execution)
                    
                    # Brief pause between commands
                    await asyncio.sleep(0.5)
            
            return executions
            
        except Exception as e:
            logger.error(f"LLM response processing error: {e}")
            return []
    
    def get_session_status(self, session_id: str) -> Optional[Dict[str, Any]]:
        """Get detailed status of a terminal session."""
        if session_id not in self.active_sessions:
            return None
        
        session = self.active_sessions[session_id]
        return {
            "session_id": session_id,
            "deployment_id": session.deployment_id,
            "swerex_session_id": session.swerex_session_id,
            "sandbox_id": session.sandbox_id,
            "created_at": session.created_at,
            "last_used": session.last_used,
            "command_count": len(session.command_history),
            "working_directory": session.working_directory,
            "is_active": session.is_active,
            "recent_commands": session.command_history[-5:] if session.command_history else []
        }
    
    def list_active_sessions(self) -> List[Dict[str, Any]]:
        """List all active terminal sessions."""
        return [
            self.get_session_status(session_id)
            for session_id in self.active_sessions.keys()
        ]
    
    async def close_session(self, session_id: str) -> bool:
        """Close and cleanup a terminal session."""
        try:
            if session_id not in self.active_sessions:
                return False
            
            session = self.active_sessions[session_id]
            session.is_active = False
            
            # Cleanup would happen here (stop deployments, etc.)
            # For now, just mark as inactive
            
            del self.active_sessions[session_id]
            logger.info(f"Closed terminal session: {session_id}")
            return True
            
        except Exception as e:
            logger.error(f"Failed to close session {session_id}: {e}")
            return False


# Global terminal executor instance
_terminal_executor = TerminalCommandExecutor()


# Function wrappers for AgentXploit integration
async def create_interactive_terminal(
    session_type: str = "development",
    base_image: str = "python:3.12",
    working_dir: str = None
) -> str:
    """
    Create an interactive terminal session with full execution capabilities.

    Args:
        session_type: Type of session ('development', 'security', 'exploit')
        base_image: Base container image
        working_dir: Working directory (defaults to PHASE4_WORKSPACE)

    Returns:
        Session ID
    """
    return await _terminal_executor.create_terminal_session(
        session_type=session_type,
        base_image=base_image,
        working_dir=working_dir
    )


async def execute_terminal_command(
    command: str,
    session_id: str,
    execution_method: str = "auto"
) -> Dict[str, Any]:
    """
    Execute a command in a terminal session.
    
    Args:
        command: Command to execute
        session_id: Session ID
        execution_method: Execution method ('swerex', 'secure', 'auto')
        
    Returns:
        Dictionary with execution results
    """
    execution = await _terminal_executor.execute_command_with_context(
        command=command,
        session_id=session_id,
        execution_method=execution_method
    )
    
    return {
        "command": execution.command,
        "success": execution.result.success,
        "stdout": execution.result.stdout,
        "stderr": execution.result.stderr,
        "return_code": execution.result.return_code,
        "execution_time": execution.result.execution_time,
        "execution_method": execution.execution_method,
        "timestamp": execution.timestamp
    }


async def process_llm_commands(
    llm_response: str,
    session_id: str,
    auto_execute: bool = True
) -> List[Dict[str, Any]]:
    """
    Process LLM response to extract and execute commands.
    
    Args:
        llm_response: LLM response text
        session_id: Session ID
        auto_execute: Whether to auto-execute commands
        
    Returns:
        List of execution results
    """
    executions = await _terminal_executor.process_llm_response_for_commands(
        llm_response=llm_response,
        session_id=session_id,
        auto_execute=auto_execute
    )
    
    return [
        {
            "command": exec.command,
            "success": exec.result.success,
            "stdout": exec.result.stdout,
            "stderr": exec.result.stderr,
            "execution_method": exec.execution_method,
            "timestamp": exec.timestamp
        }
        for exec in executions
    ]


def get_terminal_session_info(session_id: str) -> Optional[Dict[str, Any]]:
    """Get information about a terminal session."""
    return _terminal_executor.get_session_status(session_id)


def list_terminal_sessions() -> List[Dict[str, Any]]:
    """List all active terminal sessions."""
    return _terminal_executor.list_active_sessions()


async def close_terminal_session(session_id: str) -> bool:
    """Close a terminal session."""
    return await _terminal_executor.close_session(session_id)