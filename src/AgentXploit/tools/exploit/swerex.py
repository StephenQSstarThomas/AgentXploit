"""
Enhanced SWE-Rex Integration Tool

Remote Docker deployment using official SWE-Rex patterns.
"""

import asyncio
import logging
import uuid
import time
from dataclasses import dataclass
from typing import Dict, List, Optional, Any, Union

try:
    from swerex.deployment.docker import DockerDeployment
    from swerex.runtime.abstract import (
        CreateBashSessionRequest,
        BashAction,
        Command,
        CommandResponse
    )
    SWEREX_AVAILABLE = True
except ImportError:
    SWEREX_AVAILABLE = False
    logging.warning("SWE-Rex not available, using mock implementation")

logger = logging.getLogger(__name__)


@dataclass
class ExecutionResult:
    """Result of command execution."""
    command: str
    success: bool
    stdout: str
    stderr: str
    return_code: int
    execution_time: float
    session_id: Optional[str] = None


@dataclass
class DeploymentInfo:
    """Information about a SWE-Rex deployment."""
    deployment_id: str
    deployment: Any  # DockerDeployment
    runtime: Any     # RemoteRuntime
    created_at: float
    sessions: Dict[str, float]  # session_id -> created_at


class EnhancedSWEReXTool:
    """
    Enhanced SWE-Rex tool using official Docker deployment patterns.
    
    Provides remote Docker container execution following official documentation.
    """
    
    def __init__(self):
        self.deployments: Dict[str, DeploymentInfo] = {}
        
        if not SWEREX_AVAILABLE:
            logger.warning("SWE-Rex not available - using mock implementation")
    
    async def create_docker_deployment(
        self,
        image: str = "python:3.12",
        deployment_id: Optional[str] = None
    ) -> str:
        """
        Create a Docker deployment using official SWE-Rex DockerDeployment.
        
        Following the official pattern:
        from swerex.deployment.docker import DockerDeployment
        deployment = DockerDeployment(image="python:3.12")
        
        Args:
            image: Docker image to use
            deployment_id: Optional custom deployment ID
            
        Returns:
            Deployment ID
        """
        if deployment_id is None:
            deployment_id = f"docker_{uuid.uuid4().hex[:8]}"
        
        try:
            if not SWEREX_AVAILABLE:
                # Mock implementation
                logger.info(f"Mock: Created docker deployment {deployment_id} with image {image}")
                self.deployments[deployment_id] = DeploymentInfo(
                    deployment_id=deployment_id,
                    deployment=None,
                    runtime=None,
                    created_at=time.time(),
                    sessions={}
                )
                return deployment_id
            
            # Create deployment exactly as per official docs
            deployment = DockerDeployment(image=image)
            
            # Start deployment to get runtime
            await deployment.start()
            runtime = deployment.runtime
            
            # Store deployment info
            deployment_info = DeploymentInfo(
                deployment_id=deployment_id,
                deployment=deployment,
                runtime=runtime,
                created_at=time.time(),
                sessions={}
            )
            
            self.deployments[deployment_id] = deployment_info
            
            logger.info(f"Created Docker deployment: {deployment_id} with image: {image}")
            return deployment_id
            
        except Exception as e:
            logger.error(f"Failed to create Docker deployment: {e}")
            raise
    
    async def execute_command(
        self,
        command: Union[str, List[str]],
        deployment_id: str,
        timeout: Optional[float] = None,
        check: bool = False,
        shell: bool = False
    ) -> ExecutionResult:
        """
        Execute a one-off command using official SWE-Rex Command API.
        
        Args:
            command: Command to execute
            deployment_id: Target deployment
            timeout: Command timeout
            check: Whether to check exit code
            shell: Whether to use shell
            
        Returns:
            ExecutionResult with output
        """
        start_time = time.time()
        
        try:
            if deployment_id not in self.deployments:
                raise ValueError(f"Deployment not found: {deployment_id}")
            
            deployment_info = self.deployments[deployment_id]
            
            if not SWEREX_AVAILABLE:
                # Mock implementation
                await asyncio.sleep(0.1)
                return ExecutionResult(
                    command=str(command),
                    success=True,
                    stdout=f"Mock output for: {command}",
                    stderr="",
                    return_code=0,
                    execution_time=time.time() - start_time
                )
            
            runtime = deployment_info.runtime
            if runtime is None:
                raise RuntimeError(f"No runtime available for deployment: {deployment_id}")
            
            # Create Command using official API
            cmd = Command(
                command=command,
                timeout=timeout,
                check=check,
                shell=shell
            )
            
            # Execute command
            response: CommandResponse = await runtime.execute(cmd)
            
            execution_time = time.time() - start_time
            success = response.exit_code == 0 if response.exit_code is not None else True
            
            return ExecutionResult(
                command=str(command),
                success=success,
                stdout=response.stdout,
                stderr=response.stderr,
                return_code=response.exit_code or 0,
                execution_time=execution_time
            )
            
        except Exception as e:
            logger.error(f"Command execution failed: {e}")
            return ExecutionResult(
                command=str(command),
                success=False,
                stdout="",
                stderr=str(e),
                return_code=-1,
                execution_time=time.time() - start_time
            )
    
    async def create_bash_session(
        self,
        deployment_id: str,
        session_name: str = "default",
        startup_source: Optional[List[str]] = None
    ) -> str:
        """
        Create a persistent bash session using official SWE-Rex API.
        
        Args:
            deployment_id: Target deployment
            session_name: Name for the session
            startup_source: Files to source at startup
            
        Returns:
            Session name (for use with run_in_session)
        """
        try:
            if deployment_id not in self.deployments:
                raise ValueError(f"Deployment not found: {deployment_id}")
            
            deployment_info = self.deployments[deployment_id]
            
            if not SWEREX_AVAILABLE:
                # Mock implementation
                deployment_info.sessions[session_name] = time.time()
                logger.info(f"Mock: Created bash session {session_name}")
                return session_name
            
            runtime = deployment_info.runtime
            if runtime is None:
                raise RuntimeError(f"No runtime available for deployment: {deployment_id}")
            
            # Create bash session using official API
            request = CreateBashSessionRequest(
                session=session_name,
                startup_source=startup_source or []
            )
            
            await runtime.create_session(request)
            
            # Track session
            deployment_info.sessions[session_name] = time.time()
            
            logger.info(f"Created bash session: {session_name} in deployment: {deployment_id}")
            return session_name
            
        except Exception as e:
            logger.error(f"Failed to create bash session: {e}")
            raise
    
    async def run_in_session(
        self,
        command: str,
        session_name: str,
        deployment_id: str,
        timeout: Optional[float] = None,
        check_exit_code: str = "raise"
    ) -> ExecutionResult:
        """
        Run a command in a persistent bash session using official SWE-Rex API.
        
        Args:
            command: Command to run
            session_name: Session to run in
            deployment_id: Target deployment
            timeout: Command timeout
            check_exit_code: How to handle exit codes ("raise", "silent", "ignore")
            
        Returns:
            ExecutionResult with output
        """
        start_time = time.time()
        
        try:
            if deployment_id not in self.deployments:
                raise ValueError(f"Deployment not found: {deployment_id}")
            
            deployment_info = self.deployments[deployment_id]
            
            if session_name not in deployment_info.sessions:
                raise ValueError(f"Session not found: {session_name}")
            
            if not SWEREX_AVAILABLE:
                # Mock implementation
                await asyncio.sleep(0.1)
                return ExecutionResult(
                    command=command,
                    success=True,
                    stdout=f"Mock session output for: {command}",
                    stderr="",
                    return_code=0,
                    execution_time=time.time() - start_time,
                    session_id=session_name
                )
            
            runtime = deployment_info.runtime
            if runtime is None:
                raise RuntimeError(f"No runtime available for deployment: {deployment_id}")
            
            # Create BashAction using official API
            action = BashAction(
                command=command,
                session=session_name,
                timeout=timeout,
                check=check_exit_code
            )
            
            # Run in session
            response = await runtime.run_in_session(action)
            
            execution_time = time.time() - start_time
            # BashAction response has different structure than CommandResponse
            success = True  # BashAction handles errors differently
            
            # Extract output from response (structure may vary)
            stdout = getattr(response, 'output', str(response))
            stderr = ""  # BashAction typically combines output
            return_code = 0  # Success if no exception was raised
            
            return ExecutionResult(
                command=command,
                success=success,
                stdout=stdout,
                stderr=stderr,
                return_code=return_code,
                execution_time=execution_time,
                session_id=session_name
            )
            
        except Exception as e:
            logger.error(f"Session command execution failed: {e}")
            return ExecutionResult(
                command=command,
                success=False,
                stdout="",
                stderr=str(e),
                return_code=-1,
                execution_time=time.time() - start_time,
                session_id=session_name
            )
    
    async def stop_deployment(self, deployment_id: str) -> bool:
        """
        Stop a deployment using official SWE-Rex API.
        
        Args:
            deployment_id: Deployment to stop
            
        Returns:
            True if successful
        """
        try:
            if deployment_id not in self.deployments:
                logger.warning(f"Deployment not found: {deployment_id}")
                return False
            
            deployment_info = self.deployments[deployment_id]
            
            if SWEREX_AVAILABLE and deployment_info.deployment:
                await deployment_info.deployment.stop()
            
            del self.deployments[deployment_id]
            
            logger.info(f"Stopped deployment: {deployment_id}")
            return True
            
        except Exception as e:
            logger.error(f"Failed to stop deployment {deployment_id}: {e}")
            return False
    
    def get_deployment_status(self, deployment_id: str) -> Optional[Dict[str, Any]]:
        """Get deployment status information."""
        if deployment_id not in self.deployments:
            return None
        
        info = self.deployments[deployment_id]
        return {
            "deployment_id": info.deployment_id,
            "deployment_type": "docker",
            "created_at": info.created_at,
            "active_sessions": list(info.sessions.keys()),
            "session_count": len(info.sessions)
        }
    
    def list_deployments(self) -> List[Dict[str, Any]]:
        """List all active deployments."""
        return [
            self.get_deployment_status(dep_id)
            for dep_id in self.deployments.keys()
        ]


# Global tool instance
_swerex_tool = EnhancedSWEReXTool()


# Function wrappers for AgentXploit integration
async def create_deployment(
    image: str = "python:3.12",
    deployment_id: Optional[str] = None
) -> str:
    """Create a new SWE-Rex Docker deployment."""
    return await _swerex_tool.create_docker_deployment(image, deployment_id)


async def create_dev_container(
    base_image: str = "python:3.12"
) -> str:
    """Create a development container environment."""
    deployment_id = await _swerex_tool.create_docker_deployment(image=base_image)
    
    # Install common development tools using shell commands
    dev_commands = [
        "apt-get update",
        "apt-get install -y git curl wget vim nano build-essential"
    ]
    
    for cmd in dev_commands:
        result = await _swerex_tool.execute_command(cmd, deployment_id, shell=True)
        if not result.success:
            logger.warning(f"Failed to install dev tools: {cmd}")
    
    logger.info(f"Created dev container: {deployment_id}")
    return deployment_id


async def execute_command(
    command: Union[str, List[str]],
    deployment_id: str,
    timeout: Optional[float] = None
) -> ExecutionResult:
    """Execute a command in a deployment."""
    return await _swerex_tool.execute_command(
        command=command,
        deployment_id=deployment_id,
        timeout=timeout
    )


async def create_bash_session(
    deployment_id: str,
    session_name: str = "default"
) -> str:
    """Create a persistent bash session."""
    return await _swerex_tool.create_bash_session(
        deployment_id=deployment_id,
        session_name=session_name
    )


async def execute_in_session(
    command: str,
    session_name: str,
    deployment_id: str,
    timeout: Optional[float] = None
) -> ExecutionResult:
    """Execute a command in a persistent session."""
    return await _swerex_tool.run_in_session(
        command=command,
        session_name=session_name,
        deployment_id=deployment_id,
        timeout=timeout
    )


async def stop_deployment(deployment_id: str) -> bool:
    """Stop a deployment."""
    return await _swerex_tool.stop_deployment(deployment_id)


def get_deployment_status(deployment_id: str) -> Optional[Dict[str, Any]]:
    """Get deployment status."""
    return _swerex_tool.get_deployment_status(deployment_id)


def list_deployments() -> List[Dict[str, Any]]:
    """List all deployments."""
    return _swerex_tool.list_deployments()