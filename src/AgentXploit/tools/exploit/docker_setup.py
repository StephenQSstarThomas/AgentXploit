"""
Intelligent Docker Environment Setup

Process:
1. LLM reads README for Docker image information
2. If found: Create Docker → Direct to analysis (NO dependency check)  
3. If not found: Check pyproject/requirements → Create Python Docker → Run pip install → Analysis
"""

import os
import re
import json
import logging
import asyncio
from typing import Dict, Optional, Any, List
from pathlib import Path
import toml

from .swerex import (
    create_deployment, 
    create_dev_container, 
    execute_command,
    create_bash_session,
    execute_in_session
)

# Import LLM client for README analysis
from ..core.llm_client import LLMClient

logger = logging.getLogger(__name__)


class DockerEnvironmentManager:
    """
    Docker environment setup with LLM-driven README analysis using centralized LLM client
    """
    
    def __init__(self):
        logger.info("Initialized Docker Environment Manager with centralized LLM client")
    
    async def setup_docker_environment(
        self, 
        target_path: str,
        require_confirmation: bool = True
    ) -> Dict[str, Any]:
        """
        Main Docker setup process following strict requirements.
        
        Step 1: LLM analyzes README for Docker image info
        Step 2a: If found Docker image → Create Docker → Skip to analysis
        Step 2b: If no Docker → Check pyproject/requirements → Create Python Docker → pip install
        
        Args:
            target_path: Path to target project
            require_confirmation: Whether to require user confirmation
            
        Returns:
            Environment setup results
        """
        try:
            logger.info(f"Starting Docker setup for: {target_path}")
            
            # Step 1: LLM reads README for Docker information
            docker_info = await self._llm_analyze_readme(target_path)
            
            if docker_info.get('has_docker_image'):
                # Path A: Found Docker image in README → Create Docker → Direct to analysis
                logger.info("Found Docker image in README, creating environment")
                return await self._setup_from_readme_docker(
                    docker_info, require_confirmation
                )
            else:
                # Path B: No Docker → Check dependencies → Create Python Docker → pip install
                logger.info("No Docker image found, checking Python dependencies")
                return await self._setup_python_with_dependencies(
                    target_path, require_confirmation
                )
            
        except Exception as e:
            logger.error(f"Docker setup failed: {e}")
            return {
                'success': False,
                'error': str(e),
                'target_path': target_path
            }
    
    async def _llm_analyze_readme(self, target_path: str) -> Dict[str, Any]:
        """
        LLM analyzes README for Docker image information.
        """
        project_path = Path(target_path)
        
        # Read README content
        readme_content = ""
        readme_files = ['README.md', 'README.rst', 'README.txt', 'readme.md']
        
        for readme_file in readme_files:
            readme_path = project_path / readme_file
            if readme_path.exists():
                try:
                    readme_content = readme_path.read_text(encoding='utf-8')[:4000]  # Limit for LLM
                    logger.info(f"Read {readme_file} for analysis")
                    break
                except Exception as e:
                    logger.warning(f"Failed to read {readme_file}: {e}")
        
        if not readme_content:
            logger.info("No README found")
            return {'has_docker_image': False}
        
        # Use centralized LLM client for analysis
        try:
            # Build LLM messages
            messages = [
                {
                    "role": "system",
                    "content": "You are an expert at analyzing README files to extract Docker setup information. Return only valid JSON responses."
                },
                {
                    "role": "user", 
                    "content": f"""README DOCKER IMAGE DETECTION

README Content:
{readme_content}

Task: Analyze this README to find Docker image information.

Look specifically for:
1. Docker image names (e.g., "python:3.9", "ubuntu:20.04", "node:18")
2. Docker pull commands  
3. Docker run commands with specific images
4. Container setup instructions

RETURN JSON:
{{
    "has_docker_image": true/false,
    "docker_image": "image:tag",
    "docker_commands": ["docker pull image:tag"],
    "reasoning": "explanation"
}}

If NO Docker image found, return has_docker_image: false."""
                }
            ]
            
            # Get model from settings
            from ...config import settings
            model = settings.EXPLOIT_AGENT_MODEL
            
            # Call LLM using centralized client
            response = LLMClient.call_llm(
                model=model,
                messages=messages,
                max_tokens=500,
                temperature=0.1
            )
            
            if response:
                result = json.loads(response)
                logger.info(f"LLM README analysis: {result.get('has_docker_image', False)}")
                return result
            else:
                logger.warning("LLM returned no response for README analysis")
                return {'has_docker_image': False}
            
        except json.JSONDecodeError as e:
            logger.warning(f"Failed to parse LLM JSON response: {e}")
            logger.warning(f"Raw LLM response: {response}")
            return {'has_docker_image': False}
        except Exception as e:
            logger.warning(f"LLM README analysis failed: {e}")
            return {'has_docker_image': False}
    
    async def _setup_from_readme_docker(
        self, 
        docker_info: Dict[str, Any], 
        require_confirmation: bool
    ) -> Dict[str, Any]:
        """
        Setup Docker from README information → Direct to analysis (NO dependency check).
        """
        docker_image = docker_info.get('docker_image', 'python:3.12')
        reasoning = docker_info.get('reasoning', '')
        
        if require_confirmation:
            print(f"\n🐳 Docker Image Found in README:")
            print(f"Image: {docker_image}")
            print(f"Reasoning: {reasoning}")
            
            confirm = input(f"\nCreate Docker environment with {docker_image}? [Y/n]: ").strip().lower()
            if confirm in ['n', 'no']:
                return {
                    'success': False,
                    'cancelled': True,
                    'message': 'User cancelled Docker setup'
                }
        
        try:
            # Create Docker deployment using swerex
            deployment_id = await create_deployment(image=docker_image)
            
            logger.info(f"Created Docker environment: {deployment_id} with image: {docker_image}")
            
            return {
                'success': True,
                'deployment_id': deployment_id,
                'docker_image': docker_image,
                'setup_type': 'readme_docker',
                'skip_dependencies': True,  # Key: Skip dependency analysis
                'ready_for_analysis': True,
                'llm_reasoning': reasoning
            }
            
        except Exception as e:
            logger.error(f"Docker creation from README failed: {e}")
            return {
                'success': False,
                'error': str(e),
                'setup_type': 'readme_docker_failed'
            }
    
    async def _setup_python_with_dependencies(
        self, 
        target_path: str,
        require_confirmation: bool
    ) -> Dict[str, Any]:
        """
        No Docker in README → Check pyproject/requirements → Create Python Docker → pip install.
        """
        project_path = Path(target_path)
        
        # Check for Python version and dependencies
        python_version = await self._detect_python_version(project_path)
        dependencies = await self._extract_dependencies(project_path)
        
        if require_confirmation:
            print(f"\n🐍 Python Environment Setup:")
            print(f"Detected Python version: {python_version['version']} (from {python_version['source']})")
            print(f"Dependencies found: {len(dependencies)} packages")
            
            if dependencies[:3]:
                print("Sample dependencies:")
                for dep in dependencies[:3]:
                    print(f"  {dep}")
            
            confirm = input(f"\nSetup Python {python_version['version']} with dependencies? [Y/n]: ").strip().lower()
            if confirm in ['n', 'no']:
                return {
                    'success': False,
                    'cancelled': True,
                    'message': 'User cancelled Python setup'
                }
        
        try:
            # Create Python Docker environment
            python_image = f"python:{python_version['version']}"
            deployment_id = await create_deployment(image=python_image)
            
            logger.info(f"Created Python Docker: {deployment_id} with Python {python_version['version']}")
            
            # Create bash session for pip install
            session_id = await create_bash_session(deployment_id, "setup_session")
            
            # Install dependencies if found
            install_results = []
            if dependencies:
                logger.info(f"Installing {len(dependencies)} dependencies")
                
                # Create requirements.txt in container
                req_content = '\n'.join(dependencies)
                write_req_cmd = f"cat > /tmp/requirements.txt << 'EOF'\n{req_content}\nEOF"
                
                result = await execute_in_session(write_req_cmd, session_id, deployment_id)
                if not result.success:
                    logger.warning("Failed to create requirements.txt")
                
                # Run pip install
                pip_cmd = "pip install -r /tmp/requirements.txt"
                result = await execute_in_session(pip_cmd, session_id, deployment_id, timeout=300.0)
                
                install_results.append({
                    'command': pip_cmd,
                    'success': result.success,
                    'output': result.stdout[-300:] if result.stdout else '',  # Last 300 chars
                    'error': result.stderr[-200:] if result.stderr else ''
                })
                
                logger.info(f"pip install completed: success={result.success}")
            
            return {
                'success': True,
                'deployment_id': deployment_id,
                'session_id': session_id,
                'docker_image': python_image,
                'python_version': python_version['version'],
                'setup_type': 'python_dependencies',
                'dependencies_installed': len(dependencies),
                'install_results': install_results,
                'detection_source': python_version['source'],
                'ready_for_analysis': True
            }
            
        except Exception as e:
            logger.error(f"Python environment setup failed: {e}")
            return {
                'success': False,
                'error': str(e),
                'setup_type': 'python_dependencies_failed'
            }
    
    async def _detect_python_version(self, project_path: Path) -> Dict[str, str]:
        """
        Detect Python version from pyproject.toml, setup.py, or requirements.txt
        """
        # Check pyproject.toml first
        pyproject_path = project_path / 'pyproject.toml'
        if pyproject_path.exists():
            try:
                pyproject_data = toml.load(pyproject_path)
                
                # Check tool.poetry.dependencies.python
                if 'tool' in pyproject_data and 'poetry' in pyproject_data['tool']:
                    deps = pyproject_data['tool']['poetry'].get('dependencies', {})
                    if 'python' in deps:
                        python_req = deps['python']
                        version_match = re.search(r'(\d+\.\d+)', python_req)
                        if version_match:
                            return {
                                'version': version_match.group(1),
                                'source': 'pyproject.toml (poetry)'
                            }
                
                # Check project.requires-python
                if 'project' in pyproject_data:
                    requires_python = pyproject_data['project'].get('requires-python', '')
                    version_match = re.search(r'>=?\s*(\d+\.\d+)', requires_python)
                    if version_match:
                        return {
                            'version': version_match.group(1),
                            'source': 'pyproject.toml (project)'
                        }
                        
            except Exception as e:
                logger.warning(f"Failed to parse pyproject.toml: {e}")
        
        # Check setup.py
        setup_path = project_path / 'setup.py'
        if setup_path.exists():
            try:
                setup_content = setup_path.read_text(encoding='utf-8')
                version_match = re.search(r'python_requires=["\']>=?\s*(\d+\.\d+)', setup_content)
                if version_match:
                    return {
                        'version': version_match.group(1),
                        'source': 'setup.py'
                    }
            except Exception as e:
                logger.warning(f"Failed to read setup.py: {e}")
        
        # Default to 3.12
        return {
            'version': '3.12',
            'source': 'default (no version detected)'
        }
    
    async def _extract_dependencies(self, project_path: Path) -> List[str]:
        """
        Extract dependencies from pyproject.toml or requirements.txt
        """
        dependencies = []
        
        # Try pyproject.toml first
        pyproject_path = project_path / 'pyproject.toml'
        if pyproject_path.exists():
            try:
                pyproject_data = toml.load(pyproject_path)
                
                # Poetry dependencies
                if 'tool' in pyproject_data and 'poetry' in pyproject_data['tool']:
                    deps = pyproject_data['tool']['poetry'].get('dependencies', {})
                    for pkg, version in deps.items():
                        if pkg != 'python':  # Skip python version requirement
                            if isinstance(version, str):
                                dependencies.append(f"{pkg}{version}")
                            else:
                                dependencies.append(pkg)
                
                # Project dependencies
                if 'project' in pyproject_data:
                    project_deps = pyproject_data['project'].get('dependencies', [])
                    dependencies.extend(project_deps)
                    
                if dependencies:
                    logger.info(f"Found {len(dependencies)} dependencies in pyproject.toml")
                    return dependencies
                    
            except Exception as e:
                logger.warning(f"Failed to parse pyproject.toml for dependencies: {e}")
        
        # Try requirements.txt files
        req_files = ['requirements.txt', 'requirements-dev.txt', 'requirements/base.txt']
        for req_file in req_files:
            req_path = project_path / req_file
            if req_path.exists():
                try:
                    req_content = req_path.read_text(encoding='utf-8')
                    dependencies = [
                        line.strip() for line in req_content.split('\n')
                        if line.strip() and not line.strip().startswith('#') and not line.strip().startswith('-')
                    ]
                    if dependencies:
                        logger.info(f"Found {len(dependencies)} dependencies in {req_file}")
                        return dependencies
                except Exception as e:
                    logger.warning(f"Failed to read {req_file}: {e}")
        
        logger.info("No dependencies found")
        return []


# Global manager instance
_docker_manager = DockerEnvironmentManager()


# Main function for AgentXploit integration
async def setup_intelligent_docker_environment(
    target_path: str,
    llm_client=None,  # Kept for compatibility but not used - uses centralized LLM client
    require_confirmation: bool = True
) -> Dict[str, Any]:
    """
    Main Docker environment setup function.
    
    Process:
    1. LLM reads README for Docker image using centralized LLM client
    2. If found: Create Docker → Skip dependency check → Ready for analysis
    3. If not: Check pyproject/requirements → Create Python Docker → pip install → Ready for analysis
    
    Args:
        target_path: Path to target project
        llm_client: LLM client (deprecated - uses centralized LLM client)
        require_confirmation: Whether to require user confirmation
        
    Returns:
        Environment setup results
    """
    global _docker_manager
    
    return await _docker_manager.setup_docker_environment(
        target_path=target_path,
        require_confirmation=require_confirmation
    )


async def quick_python_setup(python_version: str = "3.12") -> Dict[str, Any]:
    """
    Quick Python environment setup without analysis.
    
    Args:
        python_version: Python version to use
        
    Returns:
        Environment setup results
    """
    try:
        python_image = f"python:{python_version}"
        deployment_id = await create_deployment(image=python_image)
        
        logger.info(f"Created quick Python environment: {deployment_id}")
        
        return {
            'success': True,
            'deployment_id': deployment_id,
            'docker_image': python_image,
            'setup_type': 'quick_python'
        }
        
    except Exception as e:
        logger.error(f"Quick Python setup failed: {e}")
        return {
            'success': False,
            'error': str(e)
        }