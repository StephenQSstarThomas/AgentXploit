"""
Intelligent Docker Environment Setup

Process:
1. LLM reads README for Docker image information
2. If found: Create Docker â†’ Direct to analysis (NO dependency check)  
3. If not found: Check pyproject/requirements â†’ Create Python Docker â†’ Run pip install â†’ Analysis
"""

import os
import re
import json
import logging
import asyncio
from typing import Dict, Optional, Any, List
from pathlib import Path
import toml

from .swerex import (
    create_deployment, 
    create_dev_container, 
    execute_command,
    create_bash_session,
    execute_in_session
)

# Import LLM client for README analysis
from ..core.llm_client import LLMClient

logger = logging.getLogger(__name__)


class DockerEnvironmentManager:
    """
    Docker environment setup with LLM-driven README analysis using centralized LLM client
    """
    
    def __init__(self):
        logger.info("Initialized Docker Environment Manager with centralized LLM client")
    
    async def setup_docker_environment(
        self, 
        target_path: str,
        require_confirmation: bool = True
    ) -> Dict[str, Any]:
        """
        Main Docker setup process following strict requirements.
        
        Step 1: LLM analyzes README for Docker image info
        Step 2a: If found Docker image â†’ Create Docker â†’ Skip to analysis
        Step 2b: If no Docker â†’ Check pyproject/requirements â†’ Create Python Docker â†’ pip install
        
        Args:
            target_path: Path to target project
            require_confirmation: Whether to require user confirmation
            
        Returns:
            Environment setup results
        """
        try:
            logger.info(f"Starting Docker setup for: {target_path}")
            
            # Step 1: LLM reads README for Docker information
            docker_info = await self._llm_analyze_readme(target_path)
            
            if docker_info.get('has_docker_image'):
                # Path A: Found Docker image in README â†’ Create Docker â†’ Direct to analysis
                logger.info("Found Docker image in README, creating environment")
                return await self._setup_from_readme_docker(
                    docker_info, require_confirmation
                )
            else:
                # Path B: No Docker â†’ Check dependencies â†’ Create Python Docker â†’ pip install
                logger.info("No Docker image found, checking Python dependencies")
                return await self._setup_python_with_dependencies(
                    target_path, require_confirmation
                )
            
        except Exception as e:
            logger.error(f"Docker setup failed: {e}")
            return {
                'success': False,
                'error': str(e),
                'target_path': target_path
            }
    
    async def _llm_analyze_readme(self, target_path: str) -> Dict[str, Any]:
        """
        LLM analyzes README for Docker image information.
        """
        project_path = Path(target_path)
        
        # Read README content
        readme_content = ""
        readme_files = ['README.md', 'README.rst', 'README.txt', 'readme.md']
        
        for readme_file in readme_files:
            readme_path = project_path / readme_file
            if readme_path.exists():
                try:
                    readme_content = readme_path.read_text(encoding='utf-8')[:4000]  # Limit for LLM
                    logger.info(f"Read {readme_file} for analysis")
                    break
                except Exception as e:
                    logger.warning(f"Failed to read {readme_file}: {e}")
        
        if not readme_content:
            logger.info("No README found")
            return {'has_docker_image': False}
        
        # Use centralized LLM client for analysis
        try:
            # Build LLM messages
            messages = [
                {
                    "role": "system",
                    "content": "You are an expert at analyzing README files to extract Docker setup information. Return only valid JSON responses."
                },
                {
                    "role": "user", 
                    "content": f"""README DOCKER IMAGE DETECTION

README Content:
{readme_content}

Task: Analyze this README to find Docker image information.

Look specifically for:
1. Docker image names (e.g., "python:3.9", "ubuntu:20.04", "node:18")
2. Docker pull commands  
3. Docker run commands with specific images
4. Container setup instructions

RETURN JSON:
{{
    "has_docker_image": true/false,
    "docker_image": "image:tag",
    "docker_commands": ["docker pull image:tag"],
    "reasoning": "explanation"
}}

If NO Docker image found, return has_docker_image: false."""
                }
            ]
            
            # Get model from settings
            from ...config import settings
            model = settings.EXPLOIT_AGENT_MODEL
            
            # Call LLM using centralized client
            response = LLMClient.call_llm(
                model=model,
                messages=messages,
                max_tokens=500,
                temperature=0.1
            )
            
            if response:
                result = json.loads(response)
                logger.info(f"LLM README analysis: {result.get('has_docker_image', False)}")
                return result
            else:
                logger.warning("LLM returned no response for README analysis")
                return {'has_docker_image': False}
            
        except json.JSONDecodeError as e:
            logger.warning(f"Failed to parse LLM JSON response: {e}")
            logger.warning(f"Raw LLM response: {response}")
            return {'has_docker_image': False}
        except Exception as e:
            logger.warning(f"LLM README analysis failed: {e}")
            return {'has_docker_image': False}
    
    async def _setup_from_readme_docker(
        self, 
        docker_info: Dict[str, Any], 
        require_confirmation: bool
    ) -> Dict[str, Any]:
        """
        Setup Docker from README information â†’ Direct to analysis (NO dependency check).
        """
        docker_image = docker_info.get('docker_image', 'python:3.12')
        reasoning = docker_info.get('reasoning', '')
        
        if require_confirmation:
            print(f"\nðŸ³ Docker Image Found in README:")
            print(f"Image: {docker_image}")
            print(f"Reasoning: {reasoning}")
            
            confirm = input(f"\nCreate Docker environment with {docker_image}? [Y/n]: ").strip().lower()
            if confirm in ['n', 'no']:
                return {
                    'success': False,
                    'cancelled': True,
                    'message': 'User cancelled Docker setup'
                }
        
        try:
            # Create Docker deployment using swerex
            deployment_id = await create_deployment(image=docker_image)
            
            logger.info(f"Created Docker environment: {deployment_id} with image: {docker_image}")
            
            return {
                'success': True,
                'deployment_id': deployment_id,
                'docker_image': docker_image,
                'setup_type': 'readme_docker',
                'skip_dependencies': True,  # Key: Skip dependency analysis
                'ready_for_analysis': True,
                'llm_reasoning': reasoning
            }
            
        except Exception as e:
            logger.error(f"Docker creation from README failed: {e}")
            return {
                'success': False,
                'error': str(e),
                'setup_type': 'readme_docker_failed'
            }
    
    async def _setup_python_with_dependencies(
        self, 
        target_path: str,
        require_confirmation: bool
    ) -> Dict[str, Any]:
        """
        No Docker in README â†’ Check pyproject/requirements â†’ Create Python Docker â†’ pip install.
        """
        project_path = Path(target_path)
        
        # Check for Python version and dependencies
        python_version = await self._detect_python_version(project_path)
        dependencies = await self._extract_dependencies(project_path)
        
        if require_confirmation:
            print(f"\nðŸ Python Environment Setup:")
            print(f"Detected Python version: {python_version['version']} (from {python_version['source']})")
            print(f"Dependencies found: {len(dependencies)} packages")
            
            if dependencies[:3]:
                print("Sample dependencies:")
                for dep in dependencies[:3]:
                    print(f"  {dep}")
            
            confirm = input(f"\nSetup Python {python_version['version']} with dependencies? [Y/n]: ").strip().lower()
            if confirm in ['n', 'no']:
                return {
                    'success': False,
                    'cancelled': True,
                    'message': 'User cancelled Python setup'
                }
        
        try:
            # Create Python Docker environment
            python_image = f"python:{python_version['version']}"
            deployment_id = await create_deployment(image=python_image)
            
            logger.info(f"Created Python Docker: {deployment_id} with Python {python_version['version']}")
            
            # Create bash session for pip install
            session_id = await create_bash_session(deployment_id, "setup_session")
            
            # Install dependencies if found
            install_results = []
            if dependencies:
                logger.info(f"Installing {len(dependencies)} dependencies")
                
                # Create requirements.txt in container
                req_content = '\n'.join(dependencies)
                write_req_cmd = f"cat > /tmp/requirements.txt << 'EOF'\n{req_content}\nEOF"
                
                result = await execute_in_session(write_req_cmd, session_id, deployment_id)
                if not result.success:
                    logger.warning("Failed to create requirements.txt")
                
                # Run pip install
                pip_cmd = "pip install -r /tmp/requirements.txt"
                result = await execute_in_session(pip_cmd, session_id, deployment_id, timeout=300.0)
                
                install_results.append({
                    'command': pip_cmd,
                    'success': result.success,
                    'output': result.stdout[-300:] if result.stdout else '',  # Last 300 chars
                    'error': result.stderr[-200:] if result.stderr else ''
                })
                
                logger.info(f"pip install completed: success={result.success}")
            
            return {
                'success': True,
                'deployment_id': deployment_id,
                'session_id': session_id,
                'docker_image': python_image,
                'python_version': python_version['version'],
                'setup_type': 'python_dependencies',
                'dependencies_installed': len(dependencies),
                'install_results': install_results,
                'detection_source': python_version['source'],
                'ready_for_analysis': True
            }
            
        except Exception as e:
            logger.error(f"Python environment setup failed: {e}")
            return {
                'success': False,
                'error': str(e),
                'setup_type': 'python_dependencies_failed'
            }
    
    async def _detect_python_version(self, project_path: Path) -> Dict[str, str]:
        """
        Detect Python version from pyproject.toml, setup.py, or requirements.txt
        """
        # Check pyproject.toml first
        pyproject_path = project_path / 'pyproject.toml'
        if pyproject_path.exists():
            try:
                pyproject_data = toml.load(pyproject_path)
                
                # Check tool.poetry.dependencies.python
                if 'tool' in pyproject_data and 'poetry' in pyproject_data['tool']:
                    deps = pyproject_data['tool']['poetry'].get('dependencies', {})
                    if 'python' in deps:
                        python_req = deps['python']
                        version_match = re.search(r'(\d+\.\d+)', python_req)
                        if version_match:
                            return {
                                'version': version_match.group(1),
                                'source': 'pyproject.toml (poetry)'
                            }
                
                # Check project.requires-python
                if 'project' in pyproject_data:
                    requires_python = pyproject_data['project'].get('requires-python', '')
                    version_match = re.search(r'>=?\s*(\d+\.\d+)', requires_python)
                    if version_match:
                        return {
                            'version': version_match.group(1),
                            'source': 'pyproject.toml (project)'
                        }
                        
            except Exception as e:
                logger.warning(f"Failed to parse pyproject.toml: {e}")
        
        # Check setup.py
        setup_path = project_path / 'setup.py'
        if setup_path.exists():
            try:
                setup_content = setup_path.read_text(encoding='utf-8')
                version_match = re.search(r'python_requires=["\']>=?\s*(\d+\.\d+)', setup_content)
                if version_match:
                    return {
                        'version': version_match.group(1),
                        'source': 'setup.py'
                    }
            except Exception as e:
                logger.warning(f"Failed to read setup.py: {e}")
        
        # Default to 3.12
        return {
            'version': '3.12',
            'source': 'default (no version detected)'
        }
    
    async def _extract_dependencies(self, project_path: Path) -> List[str]:
        """
        Extract dependencies from pyproject.toml or requirements.txt
        """
        dependencies = []
        
        # Try pyproject.toml first
        pyproject_path = project_path / 'pyproject.toml'
        if pyproject_path.exists():
            try:
                pyproject_data = toml.load(pyproject_path)
                
                # Poetry dependencies
                if 'tool' in pyproject_data and 'poetry' in pyproject_data['tool']:
                    deps = pyproject_data['tool']['poetry'].get('dependencies', {})
                    for pkg, version in deps.items():
                        if pkg != 'python':  # Skip python version requirement
                            if isinstance(version, str):
                                dependencies.append(f"{pkg}{version}")
                            else:
                                dependencies.append(pkg)
                
                # Project dependencies
                if 'project' in pyproject_data:
                    project_deps = pyproject_data['project'].get('dependencies', [])
                    dependencies.extend(project_deps)
                    
                if dependencies:
                    logger.info(f"Found {len(dependencies)} dependencies in pyproject.toml")
                    return dependencies
                    
            except Exception as e:
                logger.warning(f"Failed to parse pyproject.toml for dependencies: {e}")
        
        # Try requirements.txt files
        req_files = ['requirements.txt', 'requirements-dev.txt', 'requirements/base.txt']
        for req_file in req_files:
            req_path = project_path / req_file
            if req_path.exists():
                try:
                    req_content = req_path.read_text(encoding='utf-8')
                    dependencies = [
                        line.strip() for line in req_content.split('\n')
                        if line.strip() and not line.strip().startswith('#') and not line.strip().startswith('-')
                    ]
                    if dependencies:
                        logger.info(f"Found {len(dependencies)} dependencies in {req_file}")
                        return dependencies
                except Exception as e:
                    logger.warning(f"Failed to read {req_file}: {e}")
        
        logger.info("No dependencies found")
        return []


# Global manager instance
_docker_manager = DockerEnvironmentManager()


# Main function for AgentXploit integration
async def setup_intelligent_docker_environment(
    target_path: str,
    llm_client=None,  # Kept for compatibility but not used - uses centralized LLM client
    require_confirmation: bool = True
) -> Dict[str, Any]:
    """
    Main Docker environment setup function.
    
    Process:
    1. LLM reads README for Docker image using centralized LLM client
    2. If found: Create Docker â†’ Skip dependency check â†’ Ready for analysis
    3. If not: Check pyproject/requirements â†’ Create Python Docker â†’ pip install â†’ Ready for analysis
    
    Args:
        target_path: Path to target project
        llm_client: LLM client (deprecated - uses centralized LLM client)
        require_confirmation: Whether to require user confirmation
        
    Returns:
        Environment setup results
    """
    global _docker_manager
    
    return await _docker_manager.setup_docker_environment(
        target_path=target_path,
        require_confirmation=require_confirmation
    )


async def quick_python_setup(python_version: str = "3.12") -> Dict[str, Any]:
    """
    Quick Python environment setup without analysis.
    
    Args:
        python_version: Python version to use
        
    Returns:
        Environment setup results
    """
    try:
        python_image = f"python:{python_version}"
        deployment_id = await create_deployment(image=python_image)
        
        logger.info(f"Created quick Python environment: {deployment_id}")
        
        return {
            'success': True,
            'deployment_id': deployment_id,
            'docker_image': python_image,
            'setup_type': 'quick_python'
        }
        
    except Exception as e:
        logger.error(f"Quick Python setup failed: {e}")
        return {
            'success': False,
            'error': str(e)
        }