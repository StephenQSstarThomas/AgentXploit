"""
Intelligent Docker Environment Setup

Process:
1. LLM reads README for Docker image information
2. If found: Create Docker ‚Üí Direct to analysis (NO dependency check)  
3. If not found: Check pyproject/requirements ‚Üí Create Python Docker ‚Üí Run pip install ‚Üí Analysis
"""

import os
import re
import json
import logging
import asyncio
from typing import Dict, Optional, Any, List
from pathlib import Path
import toml

from .swerex import (
    create_deployment, 
    create_dev_container, 
    execute_command,
    create_bash_session,
    execute_in_session
)

# Import centralized LLM functionality
from litellm import completion

logger = logging.getLogger(__name__)


class DockerEnvironmentManager:
    """
    Docker environment setup with LLM-driven README analysis using centralized LLM client
    """
    
    def __init__(self, llm_client=None):
        self.llm_client = llm_client
        if llm_client:
            logger.info("Initialized Docker Environment Manager with provided LLM client")
        else:
            logger.info("Initialized Docker Environment Manager with centralized LLM client")
    
    async def setup_docker_environment(
        self, 
        target_path: str,
        require_confirmation: bool = True
    ) -> Dict[str, Any]:
        """
        Main Docker setup process following strict requirements.
        
        Step 1: LLM analyzes README for Docker image info
        Step 2a: If found Docker image ‚Üí Create Docker ‚Üí Skip to analysis
        Step 2b: If no Docker ‚Üí Check pyproject/requirements ‚Üí Create Python Docker ‚Üí pip install
        
        Args:
            target_path: Path to target project
            require_confirmation: Whether to require user confirmation
            
        Returns:
            Environment setup results
        """
        try:
            logger.info(f"Starting Docker setup for: {target_path}")
            
            # Step 1: LLM reads README for Docker information
            docker_info = await self._llm_analyze_readme(target_path)
            
            if docker_info.get('has_docker_image'):
                # Path A: Found Docker image in README ‚Üí Create Docker ‚Üí Direct to analysis
                logger.info("Found Docker image in README, creating environment")
                return await self._setup_from_readme_docker(
                    docker_info, require_confirmation
                )
            else:
                # Path B: No Docker ‚Üí Check dependencies ‚Üí Create Python Docker ‚Üí pip install
                logger.info("No Docker image found, checking Python dependencies")
                return await self._setup_python_with_dependencies(
                    target_path, require_confirmation
                )
            
        except Exception as e:
            logger.error(f"Docker setup failed: {e}")
            return {
                'success': False,
                'error': str(e),
                'target_path': target_path
            }
    
    async def _llm_analyze_readme(self, target_path: str) -> Dict[str, Any]:
        """
        LLM analyzes README for Docker image information.
        """
        project_path = Path(target_path)
        
        # Read README content with smart Docker section extraction
        readme_content = ""
        readme_files = ['README.md', 'README.rst', 'README.txt', 'readme.md']
        
        for readme_file in readme_files:
            readme_path = project_path / readme_file
            if readme_path.exists():
                try:
                    full_content = readme_path.read_text(encoding='utf-8')
                    logger.info(f"Read {readme_file} for analysis")
                    
                    # Extract Docker-relevant sections
                    readme_content = self._extract_docker_sections(full_content)
                    break
                except Exception as e:
                    logger.warning(f"Failed to read {readme_file}: {e}")
        
        if not readme_content:
            logger.info("No README found")
            return {'has_docker_image': False}
        
        # Use provided LLM client or fallback to centralized LLM client
        try:
            if self.llm_client:
                # Use provided LLM client (from exploit agent)
                logger.info("Using provided LLM client for README analysis")
                
                prompt = f"""Analyze this README file to detect Docker setup information.

README Content:
{readme_content}

Look for:
- Docker image names (python:3.9, ubuntu:20.04, etc.)
- docker pull commands
- docker run commands
- Container instructions

Return ONLY valid JSON in this exact format:
{{
    "has_docker_image": false,
    "docker_image": "",
    "docker_commands": [],
    "reasoning": "No Docker commands found"
}}

If Docker is found, set has_docker_image to true and fill in the details."""

                # Use the Agent SDK LLM client approach
                from google.adk.models.llm_request import LlmRequest
                
                request = LlmRequest(
                    messages=[
                        {
                            "role": "user",
                            "content": prompt
                        }
                    ]
                )
                
                # Generate response asynchronously
                response_generator = self.llm_client.generate_content_async(request)
                response = None
                async for resp in response_generator:
                    response = resp.content
                    break  # Get first response
            else:
                # Fallback to centralized LLM client
                logger.info("Using centralized LLM client for README analysis")
                
                # Build LLM messages
                messages = [
                    {
                        "role": "system",
                        "content": "You are an expert at analyzing README files to extract Docker setup information. Return only valid JSON responses."
                    },
                    {
                        "role": "user", 
                        "content": f"""Analyze this README file to detect Docker setup information.

README Content:
{readme_content}

Look for:
- Docker image names (python:3.9, ubuntu:20.04, etc.)
- docker pull commands
- docker run commands
- Container instructions

Return ONLY valid JSON in this exact format:
{{
    "has_docker_image": false,
    "docker_image": "",
    "docker_commands": [],
    "reasoning": "No Docker commands found"
}}

If Docker is found, set has_docker_image to true and fill in the details."""
                    }
                ]
                
                # Get model from settings and setup API key
                from ...config import settings
                import os
                if not os.environ.get("OPENAI_API_KEY"):
                    api_key = settings.get_openai_api_key()
                    os.environ["OPENAI_API_KEY"] = api_key
                
                model = settings.EXPLOIT_AGENT_MODEL
                
                # Call LLM directly using litellm
                llm_response = completion(
                    model=model,
                    messages=messages,
                    max_tokens=500,
                    temperature=0.1
                )
                
                # Extract content from response
                response = llm_response.choices[0].message.content
            
            if response:
                # Clean up response - remove markdown formatting
                cleaned_response = response.strip()
                
                # Remove markdown code blocks completely
                if cleaned_response.startswith('```json'):
                    cleaned_response = cleaned_response[7:]
                elif cleaned_response.startswith('```'):
                    cleaned_response = cleaned_response[3:]
                    
                if cleaned_response.endswith('```'):
                    cleaned_response = cleaned_response[:-3]
                    
                cleaned_response = cleaned_response.strip()
                
                result = json.loads(cleaned_response)
                logger.info(f"LLM README analysis: {result.get('has_docker_image', False)}")
                return result
            else:
                logger.warning("LLM returned no response for README analysis")
                return {'has_docker_image': False}
            
        except json.JSONDecodeError as e:
            logger.warning(f"Failed to parse LLM JSON response: {e}")
            logger.warning(f"Raw LLM response: {response}")
            return {'has_docker_image': False}
        except Exception as e:
            logger.warning(f"LLM README analysis failed: {e}")
            return {'has_docker_image': False}
    
    async def _setup_from_readme_docker(
        self, 
        docker_info: Dict[str, Any], 
        require_confirmation: bool
    ) -> Dict[str, Any]:
        """
        Setup Docker from README information ‚Üí Direct to analysis (NO dependency check).
        """
        docker_image = docker_info.get('docker_image', 'python:3.12')
        reasoning = docker_info.get('reasoning', '')
        
        if require_confirmation:
            print(f"\nüê≥ Docker Image Found in README:")
            print(f"Image: {docker_image}")
            print(f"Reasoning: {reasoning}")
            
            confirm = input(f"\nCreate Docker environment with {docker_image}? [Y/n]: ").strip().lower()
            if confirm in ['n', 'no']:
                return {
                    'success': False,
                    'cancelled': True,
                    'message': 'User cancelled Docker setup'
                }
        
        try:
            # Create Docker deployment using swerex
            deployment_id = await create_deployment(image=docker_image)
            
            logger.info(f"Created Docker environment: {deployment_id} with image: {docker_image}")
            
            return {
                'success': True,
                'deployment_id': deployment_id,
                'docker_image': docker_image,
                'setup_type': 'readme_docker',
                'skip_dependencies': True,  # Key: Skip dependency analysis
                'ready_for_analysis': True,
                'llm_reasoning': reasoning
            }
            
        except Exception as e:
            logger.error(f"Docker creation from README failed: {e}")
            return {
                'success': False,
                'error': str(e),
                'setup_type': 'readme_docker_failed'
            }
    
    async def _setup_python_with_dependencies(
        self, 
        target_path: str,
        require_confirmation: bool
    ) -> Dict[str, Any]:
        """
        No Docker in README ‚Üí Check pyproject/requirements ‚Üí Create Python Docker ‚Üí pip install.
        """
        project_path = Path(target_path)
        
        # Check for Python version and dependencies
        python_version = await self._detect_python_version(project_path)
        dependencies = await self._extract_dependencies(project_path)
        
        if require_confirmation:
            print(f"\nüêç Python Environment Setup:")
            print(f"Detected Python version: {python_version['version']} (from {python_version['source']})")
            print(f"Dependencies found: {len(dependencies)} packages")
            
            if dependencies[:3]:
                print("Sample dependencies:")
                for dep in dependencies[:3]:
                    print(f"  {dep}")
            
            confirm = input(f"\nSetup Python {python_version['version']} with dependencies? [Y/n]: ").strip().lower()
            if confirm in ['n', 'no']:
                return {
                    'success': False,
                    'cancelled': True,
                    'message': 'User cancelled Python setup'
                }
        
        try:
            # Create Python Docker environment
            python_image = f"python:{python_version['version']}"
            deployment_id = await create_deployment(image=python_image)
            
            logger.info(f"Created Python Docker: {deployment_id} with Python {python_version['version']}")
            
            # Create bash session for pip install
            session_id = await create_bash_session(deployment_id, "setup_session")
            
            # Install dependencies if found
            install_results = []
            if dependencies:
                logger.info(f"Installing {len(dependencies)} dependencies")
                
                # Create requirements.txt in container
                req_content = '\n'.join(dependencies)
                write_req_cmd = f"cat > /tmp/requirements.txt << 'EOF'\n{req_content}\nEOF"
                
                result = await execute_in_session(write_req_cmd, session_id, deployment_id)
                if not result.success:
                    logger.warning("Failed to create requirements.txt")
                
                # Run pip install
                pip_cmd = "pip install -r /tmp/requirements.txt"
                result = await execute_in_session(pip_cmd, session_id, deployment_id, timeout=300.0)
                
                install_results.append({
                    'command': pip_cmd,
                    'success': result.success,
                    'output': result.stdout[-300:] if result.stdout else '',  # Last 300 chars
                    'error': result.stderr[-200:] if result.stderr else ''
                })
                
                logger.info(f"pip install completed: success={result.success}")
            
            return {
                'success': True,
                'deployment_id': deployment_id,
                'session_id': session_id,
                'docker_image': python_image,
                'python_version': python_version['version'],
                'setup_type': 'python_dependencies',
                'dependencies_installed': len(dependencies),
                'install_results': install_results,
                'detection_source': python_version['source'],
                'ready_for_analysis': True
            }
            
        except Exception as e:
            logger.error(f"Python environment setup failed: {e}")
            return {
                'success': False,
                'error': str(e),
                'setup_type': 'python_dependencies_failed'
            }
    
    async def _detect_python_version(self, project_path: Path) -> Dict[str, str]:
        """
        Detect Python version from pyproject.toml, setup.py, or requirements.txt
        """
        # Check pyproject.toml first
        pyproject_path = project_path / 'pyproject.toml'
        if pyproject_path.exists():
            try:
                pyproject_data = toml.load(pyproject_path)
                
                # Check tool.poetry.dependencies.python
                if 'tool' in pyproject_data and 'poetry' in pyproject_data['tool']:
                    deps = pyproject_data['tool']['poetry'].get('dependencies', {})
                    if 'python' in deps:
                        python_req = deps['python']
                        version_match = re.search(r'(\d+\.\d+)', python_req)
                        if version_match:
                            return {
                                'version': version_match.group(1),
                                'source': 'pyproject.toml (poetry)'
                            }
                
                # Check project.requires-python
                if 'project' in pyproject_data:
                    requires_python = pyproject_data['project'].get('requires-python', '')
                    version_match = re.search(r'>=?\s*(\d+\.\d+)', requires_python)
                    if version_match:
                        return {
                            'version': version_match.group(1),
                            'source': 'pyproject.toml (project)'
                        }
                        
            except Exception as e:
                logger.warning(f"Failed to parse pyproject.toml: {e}")
        
        # Check setup.py
        setup_path = project_path / 'setup.py'
        if setup_path.exists():
            try:
                setup_content = setup_path.read_text(encoding='utf-8')
                version_match = re.search(r'python_requires=["\']>=?\s*(\d+\.\d+)', setup_content)
                if version_match:
                    return {
                        'version': version_match.group(1),
                        'source': 'setup.py'
                    }
            except Exception as e:
                logger.warning(f"Failed to read setup.py: {e}")
        
        # Default to 3.12
        return {
            'version': '3.12',
            'source': 'default (no version detected)'
        }
    
    async def _extract_dependencies(self, project_path: Path) -> List[str]:
        """
        Extract dependencies from pyproject.toml or requirements.txt
        """
        dependencies = []
        
        # Try pyproject.toml first
        pyproject_path = project_path / 'pyproject.toml'
        if pyproject_path.exists():
            try:
                pyproject_data = toml.load(pyproject_path)
                
                # Poetry dependencies
                if 'tool' in pyproject_data and 'poetry' in pyproject_data['tool']:
                    deps = pyproject_data['tool']['poetry'].get('dependencies', {})
                    for pkg, version in deps.items():
                        if pkg != 'python':  # Skip python version requirement
                            if isinstance(version, str):
                                dependencies.append(f"{pkg}{version}")
                            else:
                                dependencies.append(pkg)
                
                # Project dependencies
                if 'project' in pyproject_data:
                    project_deps = pyproject_data['project'].get('dependencies', [])
                    dependencies.extend(project_deps)
                    
                if dependencies:
                    logger.info(f"Found {len(dependencies)} dependencies in pyproject.toml")
                    return dependencies
                    
            except Exception as e:
                logger.warning(f"Failed to parse pyproject.toml for dependencies: {e}")
        
        # Try requirements.txt files
        req_files = ['requirements.txt', 'requirements-dev.txt', 'requirements/base.txt']
        for req_file in req_files:
            req_path = project_path / req_file
            if req_path.exists():
                try:
                    req_content = req_path.read_text(encoding='utf-8')
                    dependencies = [
                        line.strip() for line in req_content.split('\n')
                        if line.strip() and not line.strip().startswith('#') and not line.strip().startswith('-')
                    ]
                    if dependencies:
                        logger.info(f"Found {len(dependencies)} dependencies in {req_file}")
                        return dependencies
                except Exception as e:
                    logger.warning(f"Failed to read {req_file}: {e}")
        
        logger.info("No dependencies found")
        return []
    
    def _extract_docker_sections(self, content: str, max_chars: int = 6000) -> str:
        """
        Extract Docker-relevant sections from README content.
        
        Args:
            content: Full README content
            max_chars: Maximum characters to return
            
        Returns:
            Extracted content focusing on Docker sections
        """
        lines = content.split('\n')
        relevant_lines = []
        in_docker_section = False
        context_buffer = []
        
        # Docker-related keywords to look for
        docker_keywords = [
            'docker', 'container', 'image', 'dockerfile', 'compose',
            'pull', 'run', 'build', 'installation', 'setup', 'getting started',
            'quickstart', 'quick start', 'running locally', 'local setup'
        ]
        
        for i, line in enumerate(lines):
            line_lower = line.lower()
            
            # Check if this line contains Docker-related content
            contains_docker = any(keyword in line_lower for keyword in docker_keywords)
            
            if contains_docker:
                # Add previous context if we weren't in a Docker section
                if not in_docker_section and context_buffer:
                    relevant_lines.extend(context_buffer[-3:])  # Last 3 lines of context
                
                relevant_lines.append(line)
                in_docker_section = True
                context_buffer = []
                
                # Add next few lines after Docker content
                for j in range(i + 1, min(i + 6, len(lines))):
                    relevant_lines.append(lines[j])
                    i = j  # Skip these lines in main loop
                
            elif in_docker_section:
                # Continue adding lines if we're in a Docker section
                if line.strip() == '' or line.startswith('#') or line.startswith('```'):
                    relevant_lines.append(line)
                elif any(keyword in line_lower for keyword in docker_keywords[:5]):  # Core Docker keywords
                    relevant_lines.append(line)
                else:
                    # Exit Docker section if no relevant content for 2 consecutive lines
                    if len([l for l in relevant_lines[-2:] if l.strip() and not any(k in l.lower() for k in docker_keywords[:5])]) >= 2:
                        in_docker_section = False
                    else:
                        relevant_lines.append(line)
            else:
                # Buffer context lines when not in Docker section
                context_buffer.append(line)
                if len(context_buffer) > 5:
                    context_buffer.pop(0)
        
        # If no Docker content found, return first part of README
        if not relevant_lines:
            logger.info("No Docker-specific sections found, using first part of README")
            return content[:max_chars]
        
        # Join relevant lines and truncate if needed
        docker_content = '\n'.join(relevant_lines)
        
        if len(docker_content) > max_chars:
            logger.info(f"Docker content truncated from {len(docker_content)} to {max_chars} chars")
            docker_content = docker_content[:max_chars]
        
        logger.info(f"Extracted {len(relevant_lines)} lines of Docker-relevant content ({len(docker_content)} chars)")
        return docker_content


# Global manager instance (will be updated with LLM client when needed)
_docker_manager = None


# Main function for AgentXploit integration
async def setup_intelligent_docker_environment(
    target_path: str,
    llm_client=None,  # LLM client from exploit agent
    require_confirmation: bool = True
) -> Dict[str, Any]:
    """
    Main Docker environment setup function.
    
    Process:
    1. LLM reads README for Docker image using provided LLM client
    2. If found: Create Docker ‚Üí Skip dependency check ‚Üí Ready for analysis
    3. If not: Check pyproject/requirements ‚Üí Create Python Docker ‚Üí pip install ‚Üí Ready for analysis
    
    Args:
        target_path: Path to target project
        llm_client: LLM client from exploit agent (preferred) or None for centralized client
        require_confirmation: Whether to require user confirmation
        
    Returns:
        Environment setup results
    """
    global _docker_manager
    
    # Create or update manager with LLM client
    if llm_client:
        _docker_manager = DockerEnvironmentManager(llm_client=llm_client)
    elif _docker_manager is None:
        _docker_manager = DockerEnvironmentManager()
    
    return await _docker_manager.setup_docker_environment(
        target_path=target_path,
        require_confirmation=require_confirmation
    )


async def quick_python_setup(python_version: str = "3.12") -> Dict[str, Any]:
    """
    Quick Python environment setup without analysis.
    
    Args:
        python_version: Python version to use
        
    Returns:
        Environment setup results
    """
    try:
        python_image = f"python:{python_version}"
        deployment_id = await create_deployment(image=python_image)
        
        logger.info(f"Created quick Python environment: {deployment_id}")
        
        return {
            'success': True,
            'deployment_id': deployment_id,
            'docker_image': python_image,
            'setup_type': 'quick_python'
        }
        
    except Exception as e:
        logger.error(f"Quick Python setup failed: {e}")
        return {
            'success': False,
            'error': str(e)
        }