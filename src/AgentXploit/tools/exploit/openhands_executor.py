"""
OpenHands Specific Agent Executor

Handles execution of OpenHands agents and trace analysis specifically for OpenHands.
"""

import os
import json
import logging
import asyncio
import subprocess
from typing import Dict, List, Optional, Any
from pathlib import Path

from .swerex import execute_command

logger = logging.getLogger(__name__)


class OpenHandsExecutor:
    """Execute OpenHands agent tasks and analyze traces."""
    
    def __init__(self, target_path: str, deployment_id: str):
        self.target_path = Path(target_path)
        self.deployment_id = deployment_id
        self.config_file = None
        self.test_file = None
        
    async def detect_openhands_config(self) -> Dict[str, Any]:
        """Detect OpenHands configuration files and execution setup."""
        
        logger.info(f"Detecting OpenHands configuration in {self.target_path}")
        
        config_info = {
            "config_files": [],
            "test_files": [],
            "run_scripts": [],
            "execution_command": None,
            "trace_config": {},
            "agent_type": "openhands"
        }
        
        # Check for OpenHands specific files
        potential_configs = [
            "config.toml", "config.yaml", "config.yml", 
            "openhands.toml", ".openhands/config.toml"
        ]
        
        potential_tests = [
            "test.json", "test_data.json", "problems.json",
            "issues.json", "examples.json"
        ]
        
        potential_scripts = [
            "test_run.py", "run.py", "main.py", "start.py",
            "openhands_run.py", "agent_run.py"
        ]
        
        # Find configuration files
        for config_file in potential_configs:
            config_path = self.target_path / config_file
            if config_path.exists():
                config_info["config_files"].append(str(config_path))
                logger.info(f"Found config file: {config_file}")
                
        # Find test/problem files
        for test_file in potential_tests:
            test_path = self.target_path / test_file
            if test_path.exists():
                config_info["test_files"].append(str(test_path))
                logger.info(f"Found test file: {test_file}")
                
        # Find run scripts
        for script_file in potential_scripts:
            script_path = self.target_path / script_file
            if script_path.exists():
                config_info["run_scripts"].append(str(script_path))
                logger.info(f"Found run script: {script_file}")
        
        # Analyze found files to determine execution command
        await self._analyze_openhands_setup(config_info)
        
        return config_info
    
    async def _analyze_openhands_setup(self, config_info: Dict[str, Any]):
        """Analyze OpenHands setup to determine how to run tasks."""
        
        # Priority 1: Look for test_run.py (as mentioned by user)
        test_run_path = self.target_path / "test_run.py"
        if test_run_path.exists():
            logger.info("Found test_run.py - using this as primary execution method")
            config_info["execution_command"] = "python test_run.py"
            
            # Try to read the file to understand parameters
            try:
                with open(test_run_path, 'r') as f:
                    content = f.read()
                
                # Look for configuration details in the script
                if "save_trajectory_path" in content:
                    config_info["trace_config"]["has_trajectory"] = True
                
                if "--max-iterations" in content:
                    config_info["trace_config"]["supports_max_iterations"] = True
                    
                if "--config" in content:
                    config_info["trace_config"]["supports_config_param"] = True
                    
                if "--test" in content:
                    config_info["trace_config"]["supports_test_param"] = True
                    
            except Exception as e:
                logger.warning(f"Could not analyze test_run.py: {e}")
        
        # Priority 2: Look for standard OpenHands patterns
        elif config_info["config_files"] and config_info["test_files"]:
            config_file = config_info["config_files"][0]
            test_file = config_info["test_files"][0]
            
            # Standard OpenHands execution pattern
            config_info["execution_command"] = f"python test_run.py --config {config_file} --test {test_file} --max-iterations 10"
            
        # Try to determine trace file location from config
        await self._detect_trace_location(config_info)
    
    async def _detect_trace_location(self, config_info: Dict[str, Any]):
        """Detect where trace files will be saved."""
        
        # Check config files for trace settings
        for config_file in config_info["config_files"]:
            try:
                if config_file.endswith('.toml'):
                    import toml
                    with open(config_file, 'r') as f:
                        config_data = toml.load(f)
                    
                    # Look for trajectory/trace settings
                    if "save_trajectory_path" in config_data:
                        config_info["trace_config"]["trajectory_path"] = config_data["save_trajectory_path"]
                    
                    # Check nested configs
                    for key, value in config_data.items():
                        if isinstance(value, dict):
                            if "save_trajectory_path" in value:
                                config_info["trace_config"]["trajectory_path"] = value["save_trajectory_path"]
                                
            except Exception as e:
                logger.warning(f"Could not parse config file {config_file}: {e}")
    
    async def execute_openhands_task(
        self, 
        task_command: str = None,
        custom_prompt: str = None,
        max_iterations: int = 10
    ) -> Dict[str, Any]:
        """Execute OpenHands agent task."""
        
        logger.info("Executing OpenHands agent task")
        
        # Detect configuration if not provided
        config_info = await self.detect_openhands_config()
        
        if not task_command:
            task_command = config_info.get("execution_command")
        
        if not task_command:
            # Fallback command
            task_command = "python test_run.py --max-iterations 10"
        
        # Add max-iterations if supported and not already specified
        if "--max-iterations" not in task_command and config_info["trace_config"].get("supports_max_iterations"):
            task_command += f" --max-iterations {max_iterations}"
        
        # Add custom prompt if provided and supported
        if custom_prompt and "--prompt" not in task_command:
            # Escape the prompt properly for command line
            escaped_prompt = custom_prompt.replace('"', '\\"')
            task_command += f' --prompt "{escaped_prompt}"'
        
        logger.info(f"Executing OpenHands task: {task_command}")
        
        # Execute in the target directory
        full_command = f"cd {self.target_path} && {task_command}"
        
        result = await execute_command(
            command=full_command,
            deployment_id=self.deployment_id,
            timeout=300.0  # Allow up to 5 minutes for OpenHands execution
        )
        
        execution_result = {
            "command": task_command,
            "full_command": full_command,
            "success": result.success,
            "stdout": result.stdout,
            "stderr": result.stderr,
            "config_info": config_info
        }
        
        logger.info(f"OpenHands task execution completed. Success: {result.success}")
        
        return execution_result
    
    async def find_openhands_traces(
        self, 
        config_info: Dict[str, Any] = None,
        custom_trace_path: str = None
    ) -> List[str]:
        """Find OpenHands trace/trajectory files."""
        
        if custom_trace_path and os.path.exists(custom_trace_path):
            return [custom_trace_path]
        
        trace_files = []
        
        # Use config information if available
        if config_info and "trace_config" in config_info:
            trajectory_path = config_info["trace_config"].get("trajectory_path")
            if trajectory_path:
                traj_path = self.target_path / trajectory_path
                if traj_path.exists() and traj_path.is_dir():
                    for file_path in traj_path.glob("*.json"):
                        trace_files.append(str(file_path))
        
        # Common OpenHands trace locations
        common_trace_dirs = [
            "trajectories", "logs", "outputs", "results", 
            ".openhands", "openhands_logs", "workspace"
        ]
        
        for dir_name in common_trace_dirs:
            dir_path = self.target_path / dir_name
            if dir_path.exists() and dir_path.is_dir():
                # Look for trajectory/session files
                for pattern in ["*.json", "*trajectory*.json", "*session*.json", "instance_*.json"]:
                    for file_path in dir_path.glob(pattern):
                        if file_path.is_file():
                            trace_files.append(str(file_path))
        
        # Also check root directory for recent JSON files
        for pattern in ["*trajectory*.json", "*session*.json", "instance_*.json"]:
            for file_path in self.target_path.glob(pattern):
                if file_path.is_file():
                    trace_files.append(str(file_path))
        
        # Remove duplicates and sort by modification time (newest first)
        unique_traces = list(set(trace_files))
        unique_traces.sort(key=lambda f: os.path.getmtime(f), reverse=True)
        
        logger.info(f"Found {len(unique_traces)} OpenHands trace files")
        return unique_traces[:10]  # Return top 10 most recent
    
    async def analyze_openhands_trace(
        self, 
        trace_files: List[str]
    ) -> Dict[str, Any]:
        """Analyze OpenHands trace files for injection points."""
        
        logger.info(f"Analyzing {len(trace_files)} OpenHands trace files")
        
        injection_points = []
        external_data_sources = []
        
        for trace_file in trace_files:
            try:
                with open(trace_file, 'r', encoding='utf-8', errors='ignore') as f:
                    trace_data = json.load(f)
                
                file_analysis = await self._analyze_openhands_trace_file(trace_data, trace_file)
                injection_points.extend(file_analysis["injection_points"])
                external_data_sources.extend(file_analysis["external_sources"])
                
            except Exception as e:
                logger.warning(f"Failed to analyze OpenHands trace {trace_file}: {e}")
        
        # Deduplicate and rank injection points
        unique_injection_points = self._deduplicate_injection_points(injection_points)
        
        analysis_result = {
            "success": True,
            "total_trace_files": len(trace_files),
            "injection_points": unique_injection_points,
            "external_data_sources": external_data_sources,
            "high_risk_points": [p for p in unique_injection_points if p.get("risk", "").upper() == "HIGH"],
            "overall_risk": "HIGH" if any(p.get("risk", "").upper() == "HIGH" for p in unique_injection_points) else "MEDIUM"
        }
        
        return analysis_result
    
    async def _analyze_openhands_trace_file(self, trace_data: Dict, file_path: str) -> Dict[str, Any]:
        """Analyze a single OpenHands trace file."""
        
        injection_points = []
        external_sources = []
        
        # Convert trace data to searchable text
        trace_text = json.dumps(trace_data).lower()
        
        # OpenHands specific patterns
        openhands_external_patterns = [
            ("github", "GitHub API/Repository"),
            ("issue", "GitHub Issue Content"),
            ("user_input", "User Input"),
            ("web_search", "Web Search Results"), 
            ("api_call", "External API Call"),
            ("file_content", "File Content"),
            ("environment", "Environment Variables"),
            ("command_output", "Command Output")
        ]
        
        # OpenHands tool call patterns
        openhands_tool_patterns = [
            ("run", "Command Execution"),
            ("edit", "File Editing"),
            ("create", "File Creation"),
            ("write", "File Writing"),
            ("bash", "Bash Command"),
            ("python", "Python Execution"),
            ("subprocess", "Process Execution")
        ]
        
        # Check for external data sources in OpenHands context
        for pattern, description in openhands_external_patterns:
            if pattern in trace_text:
                external_sources.append({
                    "type": pattern,
                    "description": description,
                    "file": file_path,
                    "context": "openhands"
                })
        
        # Look for injection points specific to OpenHands
        for tool_pattern, tool_desc in openhands_tool_patterns:
            if tool_pattern in trace_text:
                for ext_pattern, ext_desc in openhands_external_patterns:
                    if ext_pattern in trace_text:
                        injection_points.append({
                            "type": f"OpenHands: {ext_desc} -> {tool_desc}",
                            "source": ext_pattern,
                            "target": tool_pattern,
                            "risk": self._assess_openhands_risk(ext_pattern, tool_pattern),
                            "file": file_path,
                            "description": f"OpenHands agent processes {ext_desc} and uses it for {tool_desc}",
                            "context": "openhands_agent"
                        })
        
        # Special focus on GitHub issue injection (SWE-Bench style)
        if ("issue" in trace_data or "github" in trace_text) and any(cmd in trace_text for cmd in ["run", "edit", "create", "bash"]):
            injection_points.append({
                "type": "SWE-Bench Style: GitHub Issue -> Agent Actions",
                "source": "github_issue",
                "target": "agent_tool_calls",
                "risk": "HIGH",
                "file": file_path,
                "description": "OpenHands agent receives GitHub issue content that can influence its tool calls and code modifications",
                "context": "swe_bench_vulnerability"
            })
        
        # Check for user input flowing to dangerous operations
        if "user" in trace_text and any(dangerous in trace_text for dangerous in ["rm ", "delete", "format", "sudo", "chmod"]):
            injection_points.append({
                "type": "User Input -> Dangerous Commands",
                "source": "user_input",
                "target": "dangerous_commands",
                "risk": "HIGH", 
                "file": file_path,
                "description": "User input may lead to execution of potentially dangerous system commands",
                "context": "user_command_injection"
            })
        
        return {
            "injection_points": injection_points,
            "external_sources": external_sources
        }
    
    def _assess_openhands_risk(self, source: str, target: str) -> str:
        """Assess risk level for OpenHands specific injection points."""
        
        high_risk_sources = ["github", "issue", "user_input", "web_search", "api_call"]
        high_risk_targets = ["run", "bash", "subprocess", "edit", "create", "write"]
        
        if source in high_risk_sources and target in high_risk_targets:
            return "HIGH"
        elif source in high_risk_sources or target in high_risk_targets:
            return "MEDIUM"
        else:
            return "LOW"
    
    def _deduplicate_injection_points(self, injection_points: List[Dict]) -> List[Dict]:
        """Remove duplicate injection points."""
        
        seen = set()
        unique_points = []
        
        for point in injection_points:
            key = (point.get("type"), point.get("source"), point.get("target"))
            if key not in seen:
                seen.add(key)
                unique_points.append(point)
        
        # Sort by risk level (HIGH first)
        risk_order = {"HIGH": 0, "MEDIUM": 1, "LOW": 2}
        unique_points.sort(key=lambda p: risk_order.get(p.get("risk"), 3))
        
        return unique_points


async def execute_openhands_with_trace_analysis(
    target_path: str,
    deployment_id: str,
    task_command: str = None,
    custom_prompt: str = None,
    custom_trace_path: str = None,
    max_iterations: int = 10
) -> Dict[str, Any]:
    """Execute OpenHands agent and analyze traces - complete workflow."""
    
    executor = OpenHandsExecutor(target_path, deployment_id)
    
    # Step 1: Execute OpenHands task
    logger.info("Step 1: Executing OpenHands agent task")
    execution_result = await executor.execute_openhands_task(
        task_command=task_command,
        custom_prompt=custom_prompt,
        max_iterations=max_iterations
    )
    
    # Step 2: Find trace files
    logger.info("Step 2: Finding OpenHands trace files")
    config_info = execution_result.get("config_info", {})
    trace_files = await executor.find_openhands_traces(config_info, custom_trace_path)
    
    # Step 3: Analyze traces
    if trace_files:
        logger.info("Step 3: Analyzing OpenHands trace files for injection points")
        analysis_result = await executor.analyze_openhands_trace(trace_files)
    else:
        logger.warning("No OpenHands trace files found")
        analysis_result = {
            "success": False,
            "error": "No trace files found",
            "injection_points": [],
            "external_data_sources": [],
            "high_risk_points": [],
            "overall_risk": "UNKNOWN"
        }
    
    return {
        "execution_result": execution_result,
        "trace_analysis": analysis_result,
        "trace_files_found": len(trace_files),
        "trace_files": trace_files,
        "target_path": target_path,
        "agent_type": "openhands"
    }


# Export functions
__all__ = [
    'OpenHandsExecutor',
    'execute_openhands_with_trace_analysis'
]