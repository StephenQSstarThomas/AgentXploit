"""
Docker container management tools for exploiter agent.

Two core tools:
1. docker_manager - Container lifecycle operations (start, stop, remove, status, etc.)
2. bash - Execute arbitrary commands inside docker container
"""
import logging
from typing import Optional

import docker
from docker.errors import APIError, NotFound

logger = logging.getLogger(__name__)

# Initialize docker client
client = docker.from_env()


def docker_manager(
    container_name: str,
    action: str,
    image: Optional[str] = None,
    environment: Optional[dict] = None,
    volumes: Optional[dict] = None,
    ports: Optional[dict] = None,
    network_mode: Optional[str] = None,
    working_dir: Optional[str] = None,
) -> dict:
    """Manage Docker container lifecycle.

    All target agents are containerized in Docker. This tool handles container
    lifecycle operations: creating, starting, stopping, and removing containers.

    Actions:
    - run: Create and start a new container (requires image parameter)
    - start: Start a stopped container
    - stop: Stop a running container
    - restart: Restart a container
    - remove: Remove a container (force removes even if running)
    - status: Get container status info
    - logs: Get container logs

    Args:
        container_name: Name of the docker container to operate on
        action: Operation to perform (run/start/stop/restart/remove/status/logs)
        image: Docker image name (required for 'run' action)
        environment: Environment variables dict (optional, for 'run' action)
        volumes: Volume mappings dict (optional, for 'run' action)
        ports: Port mappings dict (optional, for 'run' action)
        network_mode: Network mode (optional, for 'run' action)
        working_dir: Working directory inside container (optional, for 'run' action)

    Returns:
        dict: {
            "action": str,      # The action performed
            "success": bool,    # Whether operation succeeded
            "error": str        # Error message if failed, empty string if success
            "data": dict        # Additional data (e.g., container_id, status, logs)
        }
    """
    try:
        # Validate action
        valid_actions = ["run", "start", "stop", "restart", "remove", "status", "logs"]
        if action not in valid_actions:
            return {
                "action": action,
                "success": False,
                "error": f"Invalid action: {action}. Valid actions: {valid_actions}",
                "data": {}
            }

        # Handle 'run' action (create new container)
        if action == "run":
            if not image:
                return {
                    "action": action,
                    "success": False,
                    "error": "Image parameter is required for 'run' action",
                    "data": {}
                }

            # Build run parameters
            run_params = {
                "image": image,
                "name": container_name,
                "detach": True,
                "stdin_open": True,  # Keep stdin open for interactive commands
                "tty": True,         # Allocate TTY
            }

            # Add optional parameters if provided
            if environment is not None:
                run_params["environment"] = environment
            if volumes is not None:
                run_params["volumes"] = volumes
            if ports is not None:
                run_params["ports"] = ports
            if network_mode is not None:
                run_params["network_mode"] = network_mode
            if working_dir is not None:
                run_params["working_dir"] = working_dir

            container = client.containers.run(**run_params)

            return {
                "action": action,
                "success": True,
                "error": "",
                "data": {
                    "container_id": container.id,
                    "container_name": container.name,
                    "status": container.status
                }
            }

        # For all other actions, get existing container first
        try:
            container = client.containers.get(container_name)
        except NotFound:
            available = [c.name for c in client.containers.list(all=True)]
            return {
                "action": action,
                "success": False,
                "error": f"Container '{container_name}' not found. Available: {available}",
                "data": {}
            }

        # Execute action
        if action == "start":
            container.start()
            container.reload()
            return {
                "action": action,
                "success": True,
                "error": "",
                "data": {"status": container.status}
            }

        elif action == "stop":
            container.stop()
            container.reload()
            return {
                "action": action,
                "success": True,
                "error": "",
                "data": {"status": container.status}
            }

        elif action == "restart":
            container.restart()
            container.reload()
            return {
                "action": action,
                "success": True,
                "error": "",
                "data": {"status": container.status}
            }

        elif action == "remove":
            container.remove(force=True)
            return {
                "action": action,
                "success": True,
                "error": "",
                "data": {"removed": True}
            }

        elif action == "status":
            container.reload()
            # Get image info safely
            image_name = "unknown"
            if container.image:
                if container.image.tags:
                    image_name = container.image.tags[0]
                elif container.image.id:
                    image_name = str(container.image.id)[:12]
            return {
                "action": action,
                "success": True,
                "error": "",
                "data": {
                    "container_id": container.id,
                    "container_name": container.name,
                    "status": container.status,
                    "image": image_name,
                    "created": str(container.attrs.get("Created", "")),
                }
            }

        elif action == "logs":
            logs = container.logs(stdout=True, stderr=True, tail=1000).decode('utf-8', errors='ignore')
            return {
                "action": action,
                "success": True,
                "error": "",
                "data": {"logs": logs}
            }

    except APIError as e:
        logger.error(f"Docker API error: {e}")
        return {
            "action": action,
            "success": False,
            "error": f"Docker API error: {str(e)}",
            "data": {}
        }
    except Exception as e:
        logger.error(f"Docker manager error: {e}", exc_info=True)
        return {
            "action": action,
            "success": False,
            "error": str(e),
            "data": {}
        }

    # Should not reach here, but satisfy type checker
    return {
        "action": action,
        "success": False,
        "error": "Unexpected code path",
        "data": {}
    }


def bash(
    container_name: str,
    command: str,
    working_dir: Optional[str] = None,
    timeout: Optional[int] = 120,
) -> dict:
    """Execute bash command inside a Docker container.

    Executes arbitrary shell commands inside the specified container.
    Commands are wrapped in 'sh -c' to support shell features like
    pipes, redirects, && chaining, etc.

    Usage notes:
    - Always quote file paths that contain spaces with double quotes
    - Use '&&' to chain dependent commands
    - Use ';' when commands are independent
    - Avoid using 'cd' - prefer absolute paths or working_dir parameter
    - Output is truncated if it exceeds 30000 characters
    - Default timeout is 120 seconds (max 600 seconds / 10 minutes)

    Args:
        container_name: Name of the docker container to execute command in
        command: The bash command to execute
        working_dir: Optional working directory for command execution
        timeout: Optional timeout in seconds (default 120, max 600)

    Returns:
        dict: {
            "success": bool,    # True if command exit code is 0
            "exit_code": int,   # Command exit code
            "stdout": str,      # Standard output
            "stderr": str,      # Standard error
            "error": str        # Error message if execution failed, empty otherwise
        }
    """
    MAX_OUTPUT_CHARS = 30000
    MAX_TIMEOUT = 600

    try:
        # Validate timeout
        if timeout is None:
            timeout = 120
        timeout = min(timeout, MAX_TIMEOUT)

        # Get container
        try:
            container = client.containers.get(container_name)
        except NotFound:
            available = [c.name for c in client.containers.list(all=True)]
            return {
                "success": False,
                "exit_code": -1,
                "stdout": "",
                "stderr": "",
                "error": f"Container '{container_name}' not found. Available: {available}"
            }

        # Check container is running
        container.reload()
        if container.status != "running":
            return {
                "success": False,
                "exit_code": -1,
                "stdout": "",
                "stderr": "",
                "error": f"Container is not running (status: {container.status}). Start it first."
            }

        # Build exec command
        shell_command = ["sh", "-c", command]

        # Execute command
        exec_kwargs = {
            "cmd": shell_command,
            "demux": True,
        }
        if working_dir:
            exec_kwargs["workdir"] = working_dir

        exit_code, output = container.exec_run(**exec_kwargs)

        # Parse output
        stdout = ""
        stderr = ""
        if output:
            if output[0]:
                stdout = output[0].decode('utf-8', errors='ignore')
            if output[1]:
                stderr = output[1].decode('utf-8', errors='ignore')

        # Truncate if needed
        if len(stdout) > MAX_OUTPUT_CHARS:
            stdout = stdout[:MAX_OUTPUT_CHARS] + "\n... [output truncated]"
        if len(stderr) > MAX_OUTPUT_CHARS:
            stderr = stderr[:MAX_OUTPUT_CHARS] + "\n... [output truncated]"

        return {
            "success": exit_code == 0,
            "exit_code": exit_code,
            "stdout": stdout,
            "stderr": stderr,
            "error": ""
        }

    except APIError as e:
        logger.error(f"Docker API error during exec: {e}")
        return {
            "success": False,
            "exit_code": -1,
            "stdout": "",
            "stderr": "",
            "error": f"Docker API error: {str(e)}"
        }
    except Exception as e:
        logger.error(f"Bash execution error: {e}", exc_info=True)
        return {
            "success": False,
            "exit_code": -1,
            "stdout": "",
            "stderr": "",
            "error": str(e)
        }


def list_containers(all_containers: bool = True) -> dict:
    """List all Docker containers.

    Helper function to see available containers.

    Args:
        all_containers: If True, list all containers including stopped ones.
                       If False, only list running containers.

    Returns:
        dict: {
            "success": bool,
            "containers": list[dict],  # List of container info dicts
            "error": str
        }
    """
    try:
        containers = client.containers.list(all=all_containers)
        container_list = []
        for c in containers:
            # Get image info safely
            image_name = "unknown"
            if c.image:
                if c.image.tags:
                    image_name = c.image.tags[0]
                elif c.image.id:
                    image_name = str(c.image.id)[:12]
            container_list.append({
                "name": c.name,
                "id": c.short_id,
                "status": c.status,
                "image": image_name,
            })

        return {
            "success": True,
            "containers": container_list,
            "error": ""
        }
    except Exception as e:
        logger.error(f"List containers error: {e}", exc_info=True)
        return {
            "success": False,
            "containers": [],
            "error": str(e)
        }


__all__ = ["docker_manager", "bash", "list_containers"]
