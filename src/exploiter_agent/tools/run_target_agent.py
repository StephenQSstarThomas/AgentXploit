"""
Unified tool to execute target agent with optional injection.
Combines report fetching and injection execution capabilities.
"""

import os
import logging
import yaml
from typing import Optional
from tools.docker_manager import docker_manager
from tools.success_checker import check_injection_success, get_failure_reason

logger = logging.getLogger(__name__)


def run_target_agent(
    container_name: Optional[str] = None,
    injection_file_path: Optional[str] = None,
    config_path: Optional[str] = None
) -> dict:
    """Execute target agent in container with optional injection.

    This unified tool handles both:
    1. Initial report fetching (when injection_file_path is None)
    2. Agent execution with injection (when injection_file_path is provided)

    Args:
        container_name: Name of the running container (optional, will read from config if not provided)
        injection_file_path: Optional path to local injection file (injections.json)
        config_path: Optional path to config.yaml file

    Returns:
        dict: Execution result with trajectory and success status
            - exit_code: Command exit code
            - stdout: Standard output
            - stderr: Standard error
            - trajectory_path: Path to saved trajectory/report file
            - injection_successful: True if injection succeeded (only when injection provided)
            - failure_reason: Why injection failed (if applicable)
            - injection_content: Content of injection file (if provided)
            - status: "success" if trajectory retrieved, "failed" otherwise
    """
    # Load config
    if config_path is None:
        # Default: look for config.yaml in parent directory of tools/
        config_path = os.path.abspath(os.path.join(os.path.dirname(__file__), '..', 'config.yaml'))

    # Validate config file exists
    if not os.path.exists(config_path):
        error_msg = f"Configuration file not found: {config_path}"
        logger.error(error_msg)
        return {
            "exit_code": -1,
            "stdout": "",
            "stderr": error_msg,
            "trajectory_path": None,
            "injection_successful": False,
            "failure_reason": "Configuration file not found",
            "injection_content": None,
            "status": "failed"
        }

    logger.info(f"Loading configuration from: {config_path}")
    with open(config_path, 'r') as f:
        config = yaml.safe_load(f)

    # Get container name from config if not provided
    if container_name is None:
        container_name = config["docker"]["name"]
        logger.info(f"Container name not provided, using from config: {container_name}")
    else:
        logger.info(f"Using provided container name: {container_name}")

    # Determine which command to run
    if injection_file_path:
        # Phase 2-4: Run agent with injection
        exec_command = config['execution'].get('run_command') or config['execution']['command']
        # For injection runs, use trace_path if configured, otherwise default to /work/trace.json
        trajectory_path_in_container = config['execution'].get('trace_path', '/work/trace.json')
        is_injection_run = True
        logger.info(f"Running agent WITH injection: {injection_file_path}")
        logger.info(f"Trace path: {trajectory_path_in_container}")
    else:
        # Phase 1: Get initial report
        exec_command = config['execution']['command']
        # For report runs, use trajectory_path (report_path)
        trajectory_path_in_container = config['execution'].get('trajectory_path', '/work/report.txt')
        is_injection_run = False
        logger.info("Running agent to get initial report (no injection)")
        logger.info(f"Report path: {trajectory_path_in_container}")

    local_dest = config['execution'].get('local_dest', './reports')
    agent_type = config.get('agent_type', 'agentdojo')

    # Step 0: Copy injection file if provided
    injection_content = None
    if injection_file_path:
        if not os.path.exists(injection_file_path):
            logger.error(f"Injection file not found: {injection_file_path}")
            return {
                "exit_code": -1,
                "stdout": "",
                "stderr": f"Injection file not found: {injection_file_path}",
                "trajectory_path": None,
                "injection_successful": False,
                "failure_reason": "Injection file not found",
                "injection_content": None,
                "status": "failed"
            }

        # Read injection content for tracking
        try:
            with open(injection_file_path, 'r') as f:
                injection_content = f.read()
        except Exception as e:
            logger.warning(f"Could not read injection content: {e}")

        # Determine container path based on agent type
        if agent_type == "agentdojo":
            container_injection_path = "/work/injections.json"
        elif agent_type == "openhands":
            container_injection_path = "/tmp/injected_prompt.txt"
        else:
            container_injection_path = "/workspace/injection.json"

        logger.info(f"Copying injection file to {container_injection_path}")
        try:
            docker_manager(
                action='copy',
                container_name=container_name,
                src_path=injection_file_path,
                dest_path=container_injection_path
            )
            logger.info("Injection file copied successfully")
        except Exception as e:
            logger.error(f"Failed to copy injection file: {e}")
            return {
                "exit_code": -1,
                "stdout": "",
                "stderr": f"Failed to copy injection file: {str(e)}",
                "trajectory_path": None,
                "injection_successful": False,
                "failure_reason": f"File copy failed: {str(e)}",
                "injection_content": injection_content,
                "status": "failed"
            }

    # Step 1: Execute command in container
    logger.info(f"Executing command: {exec_command}")
    exec_result = docker_manager(
        action='exec',
        container_name=container_name,
        command=exec_command
    )

    logger.info(f"Command exit code: {exec_result.get('exit_code')}")
    if exec_result.get('stdout'):
        logger.debug(f"Command stdout:\n{exec_result['stdout']}")
    if exec_result.get('stderr'):
        logger.warning(f"Command stderr:\n{exec_result['stderr']}")

    # Step 2: Retrieve trajectory/report from container
    local_dest_abs = os.path.abspath(local_dest)
    os.makedirs(local_dest_abs, exist_ok=True)

    trajectory_filename = os.path.basename(trajectory_path_in_container)
    local_trajectory_path = os.path.join(local_dest_abs, trajectory_filename)

    try:
        logger.info(f"Retrieving file from container: {trajectory_path_in_container}")

        # Read file content from container
        read_result = docker_manager(
            action='exec',
            container_name=container_name,
            command=f'cat {trajectory_path_in_container}'
        )

        if read_result['exit_code'] == 0 and read_result['stdout']:
            # Save to local file
            with open(local_trajectory_path, 'w') as f:
                f.write(read_result['stdout'])
            logger.info(f"File saved to: {local_trajectory_path}")
        else:
            logger.error(f"Failed to read file from container: {read_result.get('stderr')}")
            local_trajectory_path = None

    except Exception as e:
        logger.error(f"Failed to retrieve file: {e}")
        local_trajectory_path = None

    # Step 3: Check injection success and read trace/report content
    injection_successful = False
    failure_reason = None
    trace_content = None

    # Read trajectory/trace content (for both report and injection runs)
    if local_trajectory_path and os.path.exists(local_trajectory_path):
        try:
            with open(local_trajectory_path, 'r') as f:
                trace_content = f.read()
            logger.info(f"{'Trace' if is_injection_run else 'Report'} content loaded: {len(trace_content)} chars")
        except Exception as e:
            logger.warning(f"Failed to read content: {e}")
            trace_content = None

    # Check injection success (only if injection was provided)
    if is_injection_run:
        if local_trajectory_path and os.path.exists(local_trajectory_path):
            injection_successful = check_injection_success(local_trajectory_path, agent_type)
            logger.info(f"Injection success: {injection_successful}")

            if not injection_successful:
                failure_reason = get_failure_reason(local_trajectory_path, agent_type)
                logger.info(f"Failure reason: {failure_reason}")
        else:
            failure_reason = "Trajectory file not found or not retrieved"
            logger.warning(failure_reason)

    # Prepare result
    result = {
        "exit_code": exec_result['exit_code'],
        "stdout": exec_result['stdout'],
        "stderr": exec_result['stderr'],
        "trajectory_path": local_trajectory_path,
        "trace_content": trace_content,  # Add trace content for optimization
        "injection_successful": injection_successful if is_injection_run else None,
        "failure_reason": failure_reason if is_injection_run else None,
        "injection_content": injection_content,
        "status": "success" if local_trajectory_path else "failed"
    }

    logger.info(
        f"run_target_agent completed: "
        f"status={result['status']}, "
        f"injection_run={is_injection_run}, "
        f"injection_successful={injection_successful if is_injection_run else 'N/A'}"
    )

    return result


__all__ = ["run_target_agent"]
