"""
File operation and bash tools for exploiter agent.

Core tools:
1. bash - Execute commands on LOCAL filesystem (includes docker management)
2. read - Read files from LOCAL filesystem
3. write - Write files to LOCAL filesystem
4. edit - Edit files on LOCAL filesystem with string replacement
5. load_injection_templates - Load injection templates by category/complexity
6. load_mutation_strategy - Load mutation strategies
7. run_target_agent - Execute a script that runs/tests the target agent
"""
import logging
import os
import subprocess
from pathlib import Path
from typing import Optional

logger = logging.getLogger(__name__)

# Constants
DEFAULT_MAX_LINES = 2000
MAX_LINE_LENGTH = 2000
MAX_OUTPUT_CHARS = 300000

# Get the tools directory path for loading templates
TOOLS_DIR = Path(__file__).parent


def bash(
    command: str,
    working_dir: Optional[str] = None,
    timeout: Optional[int] = 120,
) -> dict:
    """Execute bash command on the LOCAL system.

    Executes shell commands on the local machine. Commands are run via subprocess
    with shell=True to support shell features like pipes, redirects, && chaining, etc.

    Before executing the command, please follow these steps:

    Directory Verification:
    - If the command will create new directories or files, first verify the
      parent directory exists using 'ls' command
    - For example, before running "mkdir foo/bar", first verify "foo" exists

    Command Execution:
    - Always quote file paths that contain spaces with double quotes
    - Examples of proper quoting:
      - cd "/path/with spaces" (correct)
      - cd /path/with spaces (incorrect - will fail)
    - After ensuring proper quoting, execute the command
    - Capture the output of the command

    Usage notes:
    - The command argument is required
    - Timeout defaults to 120 seconds (max 600 seconds / 10 minutes)
    - Output is truncated if it exceeds 300000 characters
    - When issuing multiple commands, use ';' or '&&' operator to separate them
    - Try to use absolute paths and avoid 'cd' when possible

    # Managing Docker containers

    All target agents run inside Docker containers. Use docker commands via this
    bash tool to manage containers:

    Container lifecycle:
    - docker ps -a                           # List all containers
    - docker start <container_name>          # Start a stopped container
    - docker stop <container_name>           # Stop a running container
    - docker restart <container_name>        # Restart a container
    - docker rm -f <container_name>          # Force remove a container
    - docker logs <container_name>           # View container logs
    - docker inspect <container_name>        # Get detailed container info

    Creating new containers:
    - docker run -d --name <name> <image>    # Create and start container
    - docker run -dit --name <name> <image>  # Create with interactive TTY

    Container status:
    - docker ps                              # List running containers
    - docker ps -a                           # List all containers (including stopped)
    - docker inspect -f '{{.State.Status}}' <container_name>  # Get container status

    Executing commands in container:
    - docker exec <container_name> <command>     # Execute command in container
    - docker exec -it <container_name> bash      # Interactive shell (not recommended)

    Copying files to/from container:
    - docker cp <local_path> <container_name>:<container_path>  # Copy to container
    - docker cp <container_name>:<container_path> <local_path>  # Copy from container

    Important notes:
    - Always verify container exists before executing commands
    - Use 'docker ps -a' to see available containers if command fails
    - Container must be running to execute commands inside it

    Args:
        command: The bash command to execute
        working_dir: Optional working directory for command execution
        timeout: Optional timeout in seconds (default 120, max 600)

    Returns:
        dict: {
            "success": bool,    # True if command exit code is 0
            "exit_code": int,   # Command exit code
            "stdout": str,      # Standard output
            "stderr": str,      # Standard error
            "error": str        # Error message if execution failed, empty otherwise
        }
    """
    max_timeout = 600

    try:
        # Validate timeout
        if timeout is None:
            timeout = 120
        timeout = min(timeout, max_timeout)

        # Set working directory
        cwd = working_dir if working_dir else None
        if cwd and not os.path.isdir(cwd):
            return {
                "success": False,
                "exit_code": -1,
                "stdout": "",
                "stderr": "",
                "error": f"Working directory does not exist: {cwd}"
            }

        # Execute command
        result = subprocess.run(
            command,
            shell=True,
            capture_output=True,
            text=True,
            timeout=timeout,
            cwd=cwd
        )

        stdout = result.stdout
        stderr = result.stderr

        # Truncate if needed
        if len(stdout) > MAX_OUTPUT_CHARS:
            stdout = stdout[:MAX_OUTPUT_CHARS] + "\n... [output truncated]"
        if len(stderr) > MAX_OUTPUT_CHARS:
            stderr = stderr[:MAX_OUTPUT_CHARS] + "\n... [output truncated]"

        return {
            "success": result.returncode == 0,
            "exit_code": result.returncode,
            "stdout": stdout,
            "stderr": stderr,
            "error": ""
        }

    except subprocess.TimeoutExpired:
        return {
            "success": False,
            "exit_code": -1,
            "stdout": "",
            "stderr": "",
            "error": f"Command timed out after {timeout} seconds"
        }
    except Exception as e:
        logger.error(f"Bash execution error: {e}", exc_info=True)
        return {
            "success": False,
            "exit_code": -1,
            "stdout": "",
            "stderr": "",
            "error": str(e)
        }


def read(
    file_path: str,
    offset: Optional[int] = None,
    limit: Optional[int] = None
) -> dict:
    """Read a file from the LOCAL filesystem.

    You can access any file on the local machine directly by using this tool.
    If the path provided doesn't exist, an error will be returned.

    Usage:
    - The file_path parameter should be an absolute path
    - By default, it reads up to 2000 lines starting from the beginning
    - You can optionally specify a line offset and limit for long files
    - Any lines longer than 2000 characters will be truncated
    - Results are returned using cat -n format, with line numbers starting at 1
    - If file exists but is empty, you will receive a warning message

    Args:
        file_path: The absolute path to the file to read
        offset: The line number to start reading from (0-indexed). Only provide
                if the file is too large to read at once
        limit: The number of lines to read. Only provide if the file is too
               large to read at once

    Returns:
        dict: {
            "success": bool,
            "file_path": str,
            "content": str,
            "message": str
        }
    """
    try:
        abs_path = os.path.abspath(file_path)

        if not os.path.exists(abs_path):
            return {
                "success": False,
                "file_path": abs_path,
                "content": "",
                "message": f"File not found: {abs_path}"
            }

        if os.path.isdir(abs_path):
            return {
                "success": False,
                "file_path": abs_path,
                "content": "",
                "message": f"Path is a directory, not a file: {abs_path}"
            }

        with open(abs_path, 'r', encoding='utf-8', errors='ignore') as f:
            all_lines = f.readlines()

        total_lines = len(all_lines)

        # Handle empty file
        if total_lines == 0:
            return {
                "success": True,
                "file_path": abs_path,
                "content": "[File is empty]",
                "message": f"File exists but has no content: {abs_path}"
            }

        # Apply offset and limit
        start_line = offset if offset is not None else 0
        max_lines = limit if limit is not None else DEFAULT_MAX_LINES

        # Clamp start_line to valid range
        start_line = max(0, min(start_line, total_lines - 1))

        # Select lines
        end_line = min(start_line + max_lines, total_lines)
        selected_lines = all_lines[start_line:end_line]

        # Format as cat -n output (line numbers starting at 1)
        formatted_lines = []
        for i, line in enumerate(selected_lines, start=start_line + 1):
            # Truncate long lines
            line = line.rstrip('\n\r')
            if len(line) > MAX_LINE_LENGTH:
                line = line[:MAX_LINE_LENGTH] + "... [truncated]"
            formatted_lines.append(f"{i:6}\t{line}")

        content = '\n'.join(formatted_lines)

        # Build message
        lines_read = len(selected_lines)
        if lines_read < total_lines:
            message = f"Read lines {start_line + 1}-{end_line} of {total_lines} from {abs_path}"
        else:
            message = f"Read {total_lines} lines from {abs_path}"

        return {
            "success": True,
            "file_path": abs_path,
            "content": content,
            "message": message
        }

    except Exception as e:
        logger.error(f"Read error: {e}", exc_info=True)
        return {
            "success": False,
            "file_path": os.path.abspath(file_path),
            "content": "",
            "message": f"Error: {str(e)}"
        }


def write(
    file_path: str,
    content: str
) -> dict:
    """Write content to a file on the LOCAL filesystem.

    This tool will overwrite the existing file if there is one at the provided path.

    Usage:
    - The file_path parameter should be an absolute path
    - This tool will overwrite the existing file if it exists
    - If this is an existing file you want to modify, consider using the read
      tool first to see its contents, then use edit for small changes or write
      for complete replacement
    - ALWAYS prefer editing existing files. NEVER write new files unless required
    - Parent directories will be created automatically if they don't exist

    Args:
        file_path: The absolute path to the file to write
        content: The content to write to the file

    Returns:
        dict: {
            "success": bool,
            "file_path": str,
            "message": str
        }
    """
    try:
        abs_path = os.path.abspath(file_path)

        # Create parent directory if needed
        parent_dir = os.path.dirname(abs_path)
        if parent_dir and not os.path.exists(parent_dir):
            os.makedirs(parent_dir, exist_ok=True)

        # Write content
        with open(abs_path, 'w', encoding='utf-8') as f:
            f.write(content)

        # Count lines
        line_count = content.count('\n') + (1 if content and not content.endswith('\n') else 0)

        return {
            "success": True,
            "file_path": abs_path,
            "message": f"Successfully wrote {line_count} lines to {abs_path}"
        }

    except Exception as e:
        logger.error(f"Write error: {e}", exc_info=True)
        return {
            "success": False,
            "file_path": os.path.abspath(file_path),
            "message": f"Error: {str(e)}"
        }


def edit(
    file_path: str,
    old_string: str,
    new_string: str,
    replace_all: bool = False
) -> dict:
    """Perform exact string replacement in a file on the LOCAL filesystem.

    Usage:
    - You should use the read tool first to see the file's contents before editing
    - When editing text, ensure you preserve the exact indentation (tabs/spaces)
    - ALWAYS prefer editing existing files. NEVER write new files unless required
    - The edit will FAIL if old_string is not found in the file
    - The edit will FAIL if old_string appears multiple times and replace_all is False
      - Either provide a larger string with more context to make it unique
      - Or use replace_all=True to change every instance

    Use replace_all for:
    - Replacing and renaming strings across the file
    - Renaming variables or function names
    - Updating import statements throughout

    Args:
        file_path: The absolute path to the file to edit
        old_string: The text to replace (must exist in the file)
        new_string: The text to replace it with (must be different from old_string)
        replace_all: If True, replace all occurrences. If False (default), the
                     old_string must be unique in the file

    Returns:
        dict: {
            "success": bool,
            "file_path": str,
            "replacements": int,
            "message": str
        }
    """
    try:
        # Validate inputs
        if old_string == new_string:
            return {
                "success": False,
                "file_path": file_path,
                "replacements": 0,
                "message": "old_string and new_string must be different"
            }

        if not old_string:
            return {
                "success": False,
                "file_path": file_path,
                "replacements": 0,
                "message": "old_string cannot be empty"
            }

        abs_path = os.path.abspath(file_path)

        if not os.path.exists(abs_path):
            return {
                "success": False,
                "file_path": abs_path,
                "replacements": 0,
                "message": f"File not found: {abs_path}"
            }

        # Read current content
        with open(abs_path, 'r', encoding='utf-8', errors='ignore') as f:
            content = f.read()

        # Check if old_string exists
        count = content.count(old_string)
        if count == 0:
            return {
                "success": False,
                "file_path": abs_path,
                "replacements": 0,
                "message": "old_string not found in file. Make sure you're using the exact text including whitespace."
            }

        # Check uniqueness if not replace_all
        if not replace_all and count > 1:
            return {
                "success": False,
                "file_path": abs_path,
                "replacements": 0,
                "message": f"old_string appears {count} times in file. Use replace_all=True or provide more context to make it unique."
            }

        # Perform replacement
        if replace_all:
            new_content = content.replace(old_string, new_string)
            replacements = count
        else:
            new_content = content.replace(old_string, new_string, 1)
            replacements = 1

        # Write back
        with open(abs_path, 'w', encoding='utf-8') as f:
            f.write(new_content)

        return {
            "success": True,
            "file_path": abs_path,
            "replacements": replacements,
            "message": f"Successfully replaced {replacements} occurrence(s) in {abs_path}"
        }

    except Exception as e:
        logger.error(f"Edit error: {e}", exc_info=True)
        return {
            "success": False,
            "file_path": os.path.abspath(file_path),
            "replacements": 0,
            "message": f"Error: {str(e)}"
        }


def run_target_agent(
    script_path: str,
    injection_path: Optional[str] = None,
    args: Optional[str] = None,
    timeout: Optional[int] = 300,
    working_dir: Optional[str] = None,
) -> dict:
    """Execute a script that runs the target agent and tests exploit success.

    This tool executes a script file (shell, python, etc.) that contains
    the logic for running and testing the target agent. The script handles:
    - Starting/interacting with the target agent
    - Injecting payloads (if injection_path provided)
    - Verifying if the exploit succeeded

    The script is executed on the LOCAL system, not inside a container.
    This allows it to orchestrate container operations, API calls, etc.

    Script Requirements:
    - Return exit code 0 if exploit SUCCEEDED
    - Return non-zero exit code if exploit FAILED
    - Output execution logs to stdout/stderr

    Script Types Supported:
    - .sh: Executed with bash
    - .py: Executed with python/python3
    - .js: Executed with node
    - Other: Executed directly (must have shebang or be executable)

    Args:
        script_path: Absolute path to the script file (.sh, .py, etc.)
        injection_path: Optional path to injection payload file to pass to script
        args: Optional additional command line arguments
        timeout: Execution timeout in seconds (default 300, max 600)
        working_dir: Working directory for script execution

    Returns:
        dict: {
            "exploit_success": bool,  # True if exploit succeeded (exit_code == 0)
            "log_path": str,          # Absolute path to execution log file
            "stdout": str,            # Standard output (for quick reference)
            "stderr": str,            # Standard error (for debugging)
            "error": str              # Error message if execution failed
        }
    """
    import time
    max_timeout = 600

    try:
        abs_path = os.path.abspath(script_path)

        # Validate script exists
        if not os.path.exists(abs_path):
            return {
                "exploit_success": False,
                "log_path": "",
                "stdout": "",
                "stderr": "",
                "error": f"Script not found: {abs_path}"
            }

        if os.path.isdir(abs_path):
            return {
                "exploit_success": False,
                "log_path": "",
                "stdout": "",
                "stderr": "",
                "error": f"Path is a directory, not a file: {abs_path}"
            }

        # Validate timeout
        if timeout is None:
            timeout = 300
        timeout = min(timeout, max_timeout)

        # Determine working directory
        if working_dir:
            cwd = working_dir
        else:
            cwd = os.path.dirname(abs_path)

        if not os.path.isdir(cwd):
            return {
                "exploit_success": False,
                "log_path": "",
                "stdout": "",
                "stderr": "",
                "error": f"Working directory does not exist: {cwd}"
            }

        # Determine how to execute based on file extension
        ext = os.path.splitext(abs_path)[1].lower()

        if ext == '.sh':
            cmd = ['bash', abs_path]
        elif ext == '.py':
            cmd = ['python3', abs_path]
        elif ext == '.js':
            cmd = ['node', abs_path]
        else:
            cmd = [abs_path]

        # Add injection path if provided
        if injection_path:
            cmd.append(injection_path)

        # Add additional arguments if provided
        if args:
            cmd.extend(args.split())

        logger.info(f"Executing script: {' '.join(cmd)}")
        logger.info(f"Working directory: {cwd}")

        # Execute script
        result = subprocess.run(
            cmd,
            capture_output=True,
            text=True,
            timeout=timeout,
            cwd=cwd
        )

        stdout = result.stdout
        stderr = result.stderr

        # Truncate for return value if needed
        stdout_return = stdout
        stderr_return = stderr
        if len(stdout_return) > MAX_OUTPUT_CHARS:
            stdout_return = stdout_return[:MAX_OUTPUT_CHARS] + "\n... [output truncated]"
        if len(stderr_return) > MAX_OUTPUT_CHARS:
            stderr_return = stderr_return[:MAX_OUTPUT_CHARS] + "\n... [output truncated]"

        # Save full log to file
        timestamp = time.strftime('%Y%m%d_%H%M%S')
        script_name = os.path.splitext(os.path.basename(abs_path))[0]
        log_dir = os.path.join(os.path.dirname(abs_path), "logs")
        os.makedirs(log_dir, exist_ok=True)
        log_path = os.path.join(log_dir, f"{script_name}_{timestamp}.log")

        with open(log_path, 'w', encoding='utf-8') as f:
            f.write(f"=== EXECUTION LOG ===\n")
            f.write(f"Script: {abs_path}\n")
            f.write(f"Injection: {injection_path or 'None'}\n")
            f.write(f"Args: {args or 'None'}\n")
            f.write(f"Timestamp: {timestamp}\n")
            f.write(f"Exit Code: {result.returncode}\n")
            f.write(f"Exploit Success: {result.returncode == 0}\n")
            f.write(f"\n=== STDOUT ===\n{stdout}\n")
            f.write(f"\n=== STDERR ===\n{stderr}\n")

        exploit_success = result.returncode == 0
        logger.info(f"Script completed: exploit_success={exploit_success}, log={log_path}")

        return {
            "exploit_success": exploit_success,
            "log_path": log_path,
            "stdout": stdout_return,
            "stderr": stderr_return,
            "error": ""
        }

    except subprocess.TimeoutExpired:
        return {
            "exploit_success": False,
            "log_path": "",
            "stdout": "",
            "stderr": "",
            "error": f"Script timed out after {timeout} seconds"
        }
    except FileNotFoundError as e:
        return {
            "exploit_success": False,
            "log_path": "",
            "stdout": "",
            "stderr": "",
            "error": f"Interpreter not found: {str(e)}"
        }
    except Exception as e:
        logger.error(f"Script execution error: {e}", exc_info=True)
        return {
            "exploit_success": False,
            "log_path": "",
            "stdout": "",
            "stderr": "",
            "error": str(e)
        }


def load_injection_templates(
    category: Optional[str] = None,
    complexity: Optional[str] = None,
    include_simple_texts: bool = True,
    limit: Optional[int] = None
) -> dict:
    """Load injection templates from the template library.

    This tool loads prompt injection templates that can be used to craft
    injection payloads. Templates are organized by category and complexity.

    Available categories:
    - technical_debug: Debug/troubleshooting scenarios
    - system_admin: System administration commands
    - security_audit: Security testing contexts
    - performance_tuning: Performance optimization
    - error_recovery: Error handling scenarios
    - testing_validation: Testing/QA contexts
    - environment_setup: Environment configuration
    - compliance_check: Compliance/audit scenarios

    Available complexity levels:
    - basic: Simple, direct templates
    - intermediate: More sophisticated approaches
    - advanced: Complex multi-step templates
    - expert: Highly sophisticated templates

    Args:
        category: Filter by category (e.g., "technical_debug", "system_admin").
                  If None, returns all categories.
        complexity: Filter by complexity (e.g., "basic", "intermediate", "advanced", "expert").
                    If None, returns all complexity levels.
        include_simple_texts: If True, also include simple text templates (default True)
        limit: Maximum number of templates to return. If None, returns all matching.

    Returns:
        dict: {
            "success": bool,
            "templates": list[dict],  # List of template objects
            "simple_texts": list[str],  # Simple text templates (if include_simple_texts=True)
            "total_count": int,
            "message": str
        }
    """
    try:
        # Import the templates module
        from tools.injection_templates import (
            InjectionCategory,
            InjectionComplexity,
            PromptInjectionSeedsLibrary,
            texts,
            texts_ablation,
        )

        library = PromptInjectionSeedsLibrary()

        # Filter templates
        filtered_templates = []
        for _, seed in library.seeds.items():
            # Apply category filter
            if category:
                try:
                    target_category = InjectionCategory(category)
                    if seed.category != target_category:
                        continue
                except ValueError:
                    pass  # Invalid category, skip filter

            # Apply complexity filter
            if complexity:
                try:
                    target_complexity = InjectionComplexity(complexity)
                    if seed.complexity != target_complexity:
                        continue
                except ValueError:
                    pass  # Invalid complexity, skip filter

            # Convert to dict for JSON serialization
            template_dict = {
                "name": seed.name,
                "category": seed.category.value,
                "complexity": seed.complexity.value,
                "template": seed.template,
                "description": seed.description,
                "target_scenarios": seed.target_scenarios,
                "psychological_hooks": seed.psychological_hooks,
            }
            filtered_templates.append(template_dict)

        # Apply limit
        if limit and limit > 0:
            filtered_templates = filtered_templates[:limit]

        # Get simple texts if requested
        simple_texts_result = []
        if include_simple_texts:
            simple_texts_result = list(texts) + list(texts_ablation)

        return {
            "success": True,
            "templates": filtered_templates,
            "simple_texts": simple_texts_result,
            "total_count": len(filtered_templates),
            "categories_available": [c.value for c in InjectionCategory],
            "complexities_available": [c.value for c in InjectionComplexity],
            "message": f"Loaded {len(filtered_templates)} templates" + (f" for category={category}" if category else "") + (f", complexity={complexity}" if complexity else "")
        }

    except Exception as e:
        logger.error(f"Load injection templates error: {e}", exc_info=True)
        return {
            "success": False,
            "templates": [],
            "simple_texts": [],
            "total_count": 0,
            "message": f"Error loading templates: {str(e)}"
        }


def load_mutation_strategy(
    strategy_name: Optional[str] = None
) -> dict:
    """Load mutation strategies for transforming injection templates.

    Mutation strategies define how to transform a base injection template
    into different variations. Each strategy has a specific approach and
    use case.

    Available strategies:
    - user_impersonation: Write as if user is giving instructions
    - personal_authorization: Add authorization codes/markers
    - system_requirement: Frame as mandatory system protocol
    - time_constraint: Create urgent time pressure
    - quality_assurance: Present as quality validation step
    - prerequisite_chaining: Make task appear as prerequisite
    - critical_markers: Add emphasis/importance markers
    - configuration_reference: Reference system configurations
    - collaborative_tone: Use helpful, cooperative language
    - logical_necessity: Use logical reasoning justification
    - compliance_framing: Reference compliance/regulations
    - user_preference_history: Claim alignment with user preferences
    - trust_building: Use transparent, trustworthy language
    - efficiency_appeal: Frame as improving efficiency
    - assigned_directive: Present as official assigned task
    - completeness_appeal: Appeal to thoroughness
    - priority_escalation: Escalate priority level
    - reasonable_assumption: Make assumptions about expectations
    - reciprocal_framing: Frame as mutually beneficial
    - deadline_pressure: Add specific deadline urgency
    - trigger_response_chaining: Create multi-point triggers

    Args:
        strategy_name: Specific strategy to load (e.g., "user_impersonation").
                       If None, returns all strategies.

    Returns:
        dict: {
            "success": bool,
            "strategies": list[dict],  # Strategy objects with name, description, template, etc.
            "total_count": int,
            "message": str
        }
    """
    try:
        # Import the mutation strategies module
        from tools.mutation_strategies import (
            MutationMethod,
            mutation_prompt_templates,
            strategy_descriptions,
        )

        strategies_result = []

        for method in MutationMethod:
            # Filter by name if specified
            if strategy_name and method.value != strategy_name:
                continue

            # Get template and description
            template = mutation_prompt_templates.get(method, "")
            description_info = strategy_descriptions.get(method, {})

            strategy_dict = {
                "name": method.value,
                "display_name": description_info.get("name", method.value),
                "description": description_info.get("description", ""),
                "use_when": description_info.get("use_when", ""),
                "avoid_when": description_info.get("avoid_when", ""),
                "template": template,
            }
            strategies_result.append(strategy_dict)

        return {
            "success": True,
            "strategies": strategies_result,
            "total_count": len(strategies_result),
            "available_strategies": [m.value for m in MutationMethod],
            "message": f"Loaded {len(strategies_result)} mutation strategies" + (f" (filtered: {strategy_name})" if strategy_name else "")
        }

    except Exception as e:
        logger.error(f"Load mutation strategy error: {e}", exc_info=True)
        return {
            "success": False,
            "strategies": [],
            "total_count": 0,
            "message": f"Error loading strategies: {str(e)}"
        }


__all__ = [
    "bash",
    "read",
    "write",
    "edit",
    "run_target_agent",
    "load_injection_templates",
    "load_mutation_strategy",
]
