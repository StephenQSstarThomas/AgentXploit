Vulnerability Assessment Report
Target: /home/shiqiu/agentscope-0.1.1
Date: 2026-01-28
Style: Traditional Security Vulnerabilities

ENVIRONMENT & INVENTORY
- Languages: Python (primary)
- Entry points / services: gRPC agent server (agentscope/server/launcher.py + servicer.py), Flask/SocketIO Studio web UI (agentscope/studio/_app.py)
- Dangerous subsystems observed: deserialization (cloudpickle), dynamic code generation + execution, filesystem read/write/delete endpoints, subprocess execution, HTTP request handlers, gRPC services

FINDINGS

1) Insecure Deserialization via cloudpickle in gRPC server (RCE)
Category: Insecure Deserialization / RCE
Severity: Critical
Justification: Untrusted network input is passed directly to cloudpickle.loads(), which is code-execution capable. Any client that can reach the gRPC port can execute arbitrary code on the server.
Locations:
- /home/shiqiu/agentscope-0.1.1/src/agentscope/server/servicer.py:188
- /home/shiqiu/agentscope-0.1.1/src/agentscope/server/servicer.py:321
- /home/shiqiu/agentscope-0.1.1/src/agentscope/server/servicer.py:478
Minimal evidence:
- server/servicer.py:188
  agent_configs = pickle.loads(request.agent_init_args)
- server/servicer.py:321
  args = pickle.loads(raw_value)
- server/servicer.py:478
  args = pickle.loads(raw_args)
Attack scenario:
An attacker connects to the gRPC server and sends a crafted pickle payload in create_agent (agent_init_args) or call_agent_func (value/raw_args). cloudpickle will execute attacker-controlled code during deserialization.
Impact:
Remote Code Execution (RCE) with the privileges of the server process.
Preconditions/Assumptions:
- Attacker can access the gRPC port. This is possible when local_mode is disabled (binds 0.0.0.0) or when the attacker has local network access.
Remediation (preferred fix):
- Replace pickle/cloudpickle with safe, explicit serialization (e.g., protobuf messages or JSON with schema validation) for all inbound data.
Defense-in-depth:
- Require authentication + mTLS for gRPC connections; add HMAC/signature validation for any serialized blobs if migration is staged.
- Enforce strict allowlists for class/function targets on the server side.
Secure-by-default alternatives:
- Protobuf-encoded request/response types with explicit fields for args/kwargs, avoiding arbitrary object graphs.

2) Untrusted eval() in workflow config processing (RCE)
Category: Code Injection / RCE
Severity: Critical
Justification: User-controlled strings are evaluated with eval() during workflow sanitization. This executes arbitrary Python code on the server as part of normal request processing.
Locations:
- /home/shiqiu/agentscope-0.1.1/src/agentscope/web/workstation/workflow_utils.py:11
- /home/shiqiu/agentscope-0.1.1/src/agentscope/web/workstation/workflow_dag.py:289-290
- /home/shiqiu/agentscope-0.1.1/src/agentscope/studio/_app.py:607-614 (entry point /convert-to-py)
Minimal evidence:
- workflow_utils.py:11
  result = eval(s)
- workflow_dag.py:289-290
  elif is_callable_expression(value):
      raw_info["data"]["args"][key] = eval(value)
- _app.py:612-614
  content = request.json.get("data")
  status, py_code = _convert_to_py(content)
Attack scenario:
An attacker POSTs to /convert-to-py with a workflow config containing a string value like "__import__('os').system('id')" in data.args. The server evaluates it via eval(), executing arbitrary OS commands immediately.
Impact:
Remote Code Execution (RCE) during request processing.
Preconditions/Assumptions:
- Attacker can reach the Studio HTTP server. CORS is enabled for all origins and no authentication checks are present for this endpoint.
Remediation (preferred fix):
- Remove eval() usage for all user-supplied values. Treat all inputs as data; do not interpret as Python expressions.
- Replace with a safe parser or a strict allowlist of function names resolved from a static registry.
Defense-in-depth:
- Add authentication + CSRF protection for Studio endpoints.
- Validate workflow schema with a JSON schema validator and reject any unexpected types/fields.
Secure-by-default alternatives:
- Use a mapping of allowed callable identifiers to actual callables instead of evaluating user text.

3) Unauthenticated dynamic code generation and execution via /convert-to-py-and-run
Category: Remote Code Execution
Severity: Critical
Justification: The server generates a Python script from user-supplied workflow config and executes it via subprocess.Popen without authentication or sandboxing. This is an explicit remote code execution primitive.
Locations:
- /home/shiqiu/agentscope-0.1.1/src/agentscope/studio/_app.py:623-649
- /home/shiqiu/agentscope-0.1.1/src/agentscope/web/workstation/workflow_dag.py:120-147 (compile to Python source)
Minimal evidence:
- _app.py:631-648
  status, py_code = _convert_to_py(...)
  ...
  proc = subprocess.Popen(["python", tmp.name])
- workflow_dag.py:132-147
  script = f"{header}\n\n\n{main_body}\n\nif __name__ == '__main__':\n    main()\n"
Attack scenario:
A remote user POSTs a workflow config to /convert-to-py-and-run. The server compiles it into a Python script and executes it with the local Python interpreter, enabling arbitrary code execution (even without exploiting eval()).
Impact:
Remote Code Execution (RCE) and full compromise of the host running Studio.
Preconditions/Assumptions:
- Attacker can access the Studio HTTP service; endpoint is unauthenticated.
Remediation (preferred fix):
- Remove or disable this endpoint in production builds.
- If execution is required, run in a hardened sandbox (container/VM), with strict allowlists and resource limits.
Defense-in-depth:
- Require authentication/authorization and origin checks for all Studio endpoints.
- Add strict workflow validation and prohibit any user-defined code strings.
Secure-by-default alternatives:
- Execute workflows in a separate isolated worker process with seccomp/AppArmor and a read-only filesystem.

4) Arbitrary file read via unauthenticated /api/file endpoint
Category: Information Disclosure / Arbitrary File Read
Severity: High
Justification: The endpoint accepts a file path directly and returns its content via send_file without validation or access control.
Location:
- /home/shiqiu/agentscope-0.1.1/src/agentscope/studio/_app.py:593-603
Minimal evidence:
- _app.py:596-601
  file_path = request.args.get("path", None)
  ...
  file = send_file(file_path)
Attack scenario:
An attacker sends GET /api/file?path=/etc/passwd (or any readable file path). The server responds with the file contents.
Impact:
Disclosure of sensitive files (credentials, keys, configuration) and potential credential compromise.
Preconditions/Assumptions:
- Attacker can reach the Studio HTTP server; no authentication is required.
Remediation (preferred fix):
- Remove this endpoint or restrict to a safe allowlist of directories and file types.
Defense-in-depth:
- Canonicalize the requested path (realpath) and enforce a strict prefix check.
- Require authentication and audit access.
Secure-by-default alternatives:
- Serve files via opaque IDs mapped to a controlled storage directory.

5) Path traversal enabling arbitrary file read/write/delete in workflow file endpoints
Category: Path Traversal / Arbitrary File Read-Write-Delete
Severity: High
Justification: User-controlled filename is joined with a base directory without sanitization. Path traversal (../) allows escaping the intended directory, enabling read/write/delete of arbitrary files with the server's privileges.
Locations:
- /home/shiqiu/agentscope-0.1.1/src/agentscope/studio/_app.py:689-748 (save)
- /home/shiqiu/agentscope-0.1.1/src/agentscope/studio/_app.py:752-780 (delete)
- /home/shiqiu/agentscope-0.1.1/src/agentscope/studio/_app.py:800-818 (load)
Minimal evidence:
- _app.py:706
  filepath = os.path.join(user_dir, f"{filename}.json")
- _app.py:772-777
  filepath = os.path.join(user_dir, filename)
  ...
  os.remove(filepath)
- _app.py:807-812
  filepath = os.path.join(user_dir, filename)
  with open(filepath, "r", encoding="utf-8") as f:
Attack scenario:
An attacker supplies filename="../../.ssh/authorized_keys" to /save-workflow to overwrite sensitive files, or to /load-workflow and /delete-workflow to read/delete arbitrary files.
Impact:
Arbitrary file overwrite, deletion, and disclosure; may lead to privilege escalation or RCE (e.g., writing to startup scripts).
Preconditions/Assumptions:
- Attacker can access the Studio HTTP service; no authentication is required.
Remediation (preferred fix):
- Reject any filename containing path separators or ".."; enforce a strict filename regex.
- Use werkzeug.utils.secure_filename and validate resulting path with realpath prefix checks.
Defense-in-depth:
- Use per-user storage with random IDs and maintain a server-side mapping.
- Apply filesystem permissions to restrict damage.
Secure-by-default alternatives:
- Store workflows in a database keyed by UUIDs, not direct filesystem paths.

NOTES ON SCOPE
- This report focuses on traditional security vulnerabilities and does not analyze LLM prompt logic.
- The issues above are reproducible by inspecting the referenced code locations.
