Vulnerability Assessment Report (Traditional Security)
Target: /home/shiqiu/gpt_academic-3.83
Date: 2026-01-28
Scope: Codebase-only, no services executed. Focused on traditional security issues (I/O boundaries, deserialization, subprocess, file handling, network).

============================================================
ENVIRONMENT & INVENTORY
============================================================
Primary language: Python
Frameworks/entry points:
- Gradio UI + FastAPI server: shared_utils/fastapi_server.py, main.py
- Plugin system under crazy_functions/
Key subsystems reviewed:
- File upload & archive extraction: toolbox.py, shared_utils/handle_upload.py
- Network fetch helpers: crazy_functions/crazy_utils.py, pdf_fns/parse_pdf_via_doc2x.py
- Subprocess execution: crazy_functions/* (notably chatglm微调工具.py, latex_fns/latex_actions.py)
- Serialization: pickle usage in multi_stage_utils.py, vt_state.py, multi_language.py

============================================================
FINDINGS
============================================================

1) Arbitrary File Write via Path Traversal in RAR/7z Extraction (Path Traversal / File Write)
Severity: High
Location:
- shared_utils/handle_upload.py:120-138
- toolbox.py:515-523 (untrusted uploads are auto-extracted)

Evidence (excerpt):
- shared_utils/handle_upload.py:120-138
  120 elif file_extension == ".rar":
  124     with rarfile.RarFile(file_path) as rf:
  125         rf.extractall(path=dest_dir)
  ...
  132 elif file_extension == ".7z":
  136     with py7zr.SevenZipFile(file_path, mode="r") as f:
  137         f.extractall(path=dest_dir)

- toolbox.py:515-523
  517 for file in files:
  520     shutil.move(file.name, this_file_path)
  521     upload_msg += extract_archive(
  522         file_path=this_file_path, dest_dir=this_file_path + ".extract"
  523     )

Attack scenario:
An attacker uploads a crafted .rar or .7z containing entries like "../../../../gpt_academic-3.83/config.py" or "../gpt_log/default_user/…". Because extractall() is used without path validation, the archive can write outside the intended extraction directory.

Impact:
- Arbitrary file write outside upload directory.
- Potential RCE by overwriting Python modules or configuration that is later imported/executed.
- Data loss or defacement by overwriting application files.

Preconditions:
- Attacker can upload archives via the Gradio UI upload feature.
- RAR/7z extraction dependencies are installed.

Remediation (preferred minimal fix):
- Add path validation for RAR/7z entries similar to the tarfile safety check (validate that each extracted path stays within dest_dir before extraction).
- For rarfile/py7zr, iterate entries and refuse absolute paths or any containing ".." after normalization; then extract safely.

Defense-in-depth:
- Restrict supported archive types to formats with safe extraction routines.
- Extract to a sandboxed directory with least privilege, and enforce a max total extracted size.

Secure-by-default alternative:
- Use a “safe extract” helper that validates each member path, then writes explicitly to a known-safe path rather than using extractall().

------------------------------------------------------------

2) Server-Side Request Forgery (SSRF) via Unrestricted URL Fetch (SSRF)
Severity: Medium
Location:
- crazy_functions/crazy_utils.py:524-552

Evidence (excerpt):
  540 if txt.startswith('http'):
  542     import requests
  546     r = requests.get(txt, proxies=proxies)
  550     path = os.path.join(get_log_folder(plugin_name='web_download'), gen_time_str()+type)
  551     with open(path, 'wb+') as f: f.write(r.content)

Attack scenario:
A remote user provides a URL such as http://169.254.169.254/latest/meta-data/ or an internal service URL. The server performs the request and stores the response, enabling data exfiltration from internal networks.

Impact:
- Access to internal services (cloud metadata, internal APIs).
- Potential data exfiltration or pivoting into internal networks.

Preconditions:
- User can supply “txt” input to plugins that call get_files_from_everything().

Remediation (preferred minimal fix):
- Restrict URL schemes to http/https and block requests to private/loopback/link-local IP ranges.
- Add explicit allowlists for safe domains if possible.
- Add request timeout and response size limits.

Defense-in-depth:
- Use a network egress proxy with SSRF protections and DNS rebinding defenses.

------------------------------------------------------------

3) Command Injection via shell=True with User-Controlled Arguments (Command Injection / RCE)
Severity: Critical
Location:
- crazy_functions/chatglm微调工具.py:96-136

Evidence (excerpt):
  96 args = plugin_kwargs.get("advanced_arg", None)
  102 arguments = string_to_options(arguments=args)
  109 json_dataset = arguments.json_dataset
  112 command = f"torchrun ... --train_file AdvertiseGen/{json_dataset} ..."
  136 process = subprocess.Popen(command, shell=True, cwd=ptuning_directory)

Attack scenario:
An attacker supplies advanced_arg with a malicious value like:
  --json_dataset "foo.json; rm -rf /" 
Because the command is constructed as a string and run with shell=True, shell metacharacters are executed.

Impact:
- Remote code execution with the privileges of the service user.
- Potential full system compromise depending on permissions.

Preconditions:
- Attacker can invoke the “启动微调” plugin and supply advanced_arg.

Remediation (preferred minimal fix):
- Use subprocess.run([...], shell=False) with a list of arguments.
- Validate and sanitize user-provided values (e.g., allow only safe filename patterns for json_dataset).

Defense-in-depth:
- Run training commands in a restricted container or a dedicated least-privileged user.

Secure-by-default alternative:
- Build the command as a list and pass arguments directly to subprocess without a shell.

------------------------------------------------------------

4) Arbitrary Code Execution by Executing Untrusted Generated Python (Code Execution)
Severity: Critical
Location:
- crazy_functions/数学动画生成manim.py:16-33, 94-96

Evidence (excerpt):
  19 with open('gpt_log/MyAnimation.py', 'w', encoding='utf8') as f:
  20     f.write(code)
  32 subprocess.check_output([sys.executable, '-c', f"from gpt_log.MyAnimation import {class_name}; {class_name}().render()"]) 
  95 code = get_code_block(gpt_say)
  96 res = eval_manim(code)

Attack scenario:
The plugin generates Python code (influenced by user input) and executes it. A malicious prompt can cause the model to emit code that performs arbitrary system actions, leading to RCE.

Impact:
- Full remote code execution on the server.
- Data exfiltration, file modification, persistence.

Preconditions:
- Attacker can invoke the “动画生成” plugin.

Remediation (preferred minimal fix):
- Disable this plugin for untrusted users.
- Execute generated code inside a locked-down sandbox/container with no host file access.

Defense-in-depth:
- Apply static AST allowlist checks to restrict to safe Manim constructs only.
- Run in a separate container or VM with no network access and limited filesystem.

------------------------------------------------------------

5) Potential Zip-Slip via Unvalidated Extraction of Remote Zip (Path Traversal)
Severity: Low (Potential)
Location:
- crazy_functions/pdf_fns/parse_pdf_via_doc2x.py:58-68

Evidence (excerpt):
  58 res = requests.get(url, headers={...})
  66 with zipfile.ZipFile(latex_zip_path, 'r') as zip_ref:
  68     zip_ref.extractall(latex_unzip_path)

Rationale:
This zip is obtained from a third-party service (Doc2X). If the service is compromised or the response is tampered with, a malicious zip could perform path traversal on extraction. There is no path validation before extractall().

Impact:
- Potential arbitrary file write outside latex_unzip_path.

Preconditions:
- Attacker can control or tamper with the ZIP response from the external service.

Remediation:
- Validate zip members before extracting (reject absolute paths and ".." components).
- Alternatively, reuse the safe extraction helper used in shared_utils/handle_upload.py.

============================================================
NOTES / LIMITATIONS
============================================================
- This review did not execute the application. Findings are based on static analysis and code evidence.
- If you want verification for specific runtime behaviors (e.g., Gradio file endpoint protections), run-time testing is required.

