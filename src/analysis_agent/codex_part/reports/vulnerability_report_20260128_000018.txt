Traditional Security Vulnerability Assessment
Target: /home/shiqiu/gpt_academic-3.91
Date: 2026-01-28

Scope & Inventory (coverage-first)
- Primary language: Python (Gradio/FastAPI web UI + plugins).
- Entry points: main.py (Gradio app), shared_utils/fastapi_server.py (FastAPI wrapper), toolbox.py (file upload + plugin wiring).
- External input boundaries: HTTP (Gradio/FastAPI routes), file uploads, environment variables, config files, network responses from external services, local cache files.
- High-risk subsystems: archive extraction (zip/tar/rar/7z), pickle serialization, shell execution helpers, file read/write utilities.

Findings

1) Remote Code Execution via unsafe pickle deserialization from network
Category: Insecure deserialization
Severity: Critical (network-sourced pickle -> code execution)
Location: /home/shiqiu/gpt_academic-3.91/shared_utils/docker_as_service_api.py:40-78
Snippet:
    response = requests.post(server_url, files=files, stream=True)
    ...
    for chunk in response.iter_content(max_full_package_size):
        ...
        received = pickle.loads(chunk_buf)
Attack scenario:
- If an attacker can control or spoof the docker-as-a-service endpoint (server_url), they can return a malicious pickle payload. The client will unpickle it, executing attacker-controlled code.
Impact:
- Arbitrary code execution in the client process (full compromise).
Preconditions:
- Attacker can influence server_url or the server response (e.g., misconfiguration, DNS hijack, or compromised server).
Remediation (preferred):
- Replace pickle with a safe serialization format (JSON/msgpack) and explicitly validate against a schema (e.g., Pydantic models). If binary is required, use protobuf.
Defense-in-depth:
- Require TLS with certificate pinning or mutual TLS for the service.
- Enforce an allowlist of trusted server_url domains.
Secure-by-default alternatives:
- JSON + Pydantic model validation; msgpack with strict type checking.

2) Arbitrary file write via path traversal in server_file_attach handling
Category: Path traversal / arbitrary file write
Severity: High
Location: /home/shiqiu/gpt_academic-3.91/shared_utils/docker_as_service_api.py:28-37
Snippet:
    for file_name, file_content in received.server_file_attach.items():
        new_fp = os.path.join(save_file_dir, file_name)
        ...
        with open(new_fp, 'wb') as f:
            f.write(file_content)
Attack scenario:
- A malicious server can send file_name values containing "../" or absolute paths (e.g., "../../.ssh/authorized_keys" or "/etc/cron.d/x"), causing writes outside save_file_dir.
Impact:
- Arbitrary file overwrite/write on the client host; potential code execution or credential planting.
Preconditions:
- Attacker controls server response (same preconditions as Finding #1).
Remediation (preferred):
- Reject absolute paths and path traversal sequences; enforce that the resolved path stays within save_file_dir.
  Example: resolve = os.path.abspath(os.path.join(save_file_dir, file_name)); verify resolve.startswith(os.path.abspath(save_file_dir)+os.sep).
Defense-in-depth:
- Strip to basename for attachments; maintain an allowlist of extensions.
Secure-by-default alternatives:
- Use a random server-assigned filename and ignore client-provided names.

3) Archive extraction path traversal (RAR/7z) during file uploads
Category: Path traversal / arbitrary file write
Severity: High
Location: /home/shiqiu/gpt_academic-3.91/shared_utils/handle_upload.py:131-149
Snippet:
    elif file_extension == ".rar":
        ...
        with rarfile.RarFile(file_path) as rf:
            rf.extractall(path=dest_dir)
    elif file_extension == ".7z":
        ...
        with py7zr.SevenZipFile(file_path, mode="r") as f:
            f.extractall(path=dest_dir)
Attack scenario:
- An attacker uploads a crafted .rar/.7z containing entries like "../../../../etc/shadow" or absolute paths. extractall() will write outside dest_dir.
Impact:
- Arbitrary file overwrite/write on server; potential RCE if overwriting application files or adding startup scripts.
Preconditions:
- File upload is accessible to attacker (Gradio upload endpoint).
Remediation (preferred):
- Validate every archive member before extraction; reject entries that escape dest_dir.
  For rar/7z, iterate file names and validate abspath after join.
Defense-in-depth:
- Extract into a new empty temp directory and enforce permissions.
Secure-by-default alternatives:
- Use libraries with safe extraction helpers (or implement a shared safe_extract function for all formats).

4) Code execution via eval() of environment-sourced configuration
Category: Code injection
Severity: Medium
Location: /home/shiqiu/gpt_academic-3.91/shared_utils/config_loader.py:45-53
Snippet:
    elif isinstance(default_value, dict):
        r = eval(env_arg)
    elif isinstance(default_value, list):
        r = eval(env_arg)
    elif default_value is None:
        ...
        r = eval(env_arg)
Attack scenario:
- If an attacker can set environment variables (e.g., via docker-compose overrides, service config, or CI), they can inject Python code into env_arg that will execute during startup.
Impact:
- Arbitrary code execution during application boot.
Preconditions:
- Attacker can control environment variables for the service.
Remediation (preferred):
- Replace eval with safe parsers: json.loads for dict/list, or ast.literal_eval if JSON is not feasible.
Defense-in-depth:
- Whitelist allowed keys and validate types/values.
Secure-by-default alternatives:
- JSON-only configuration (reject non-JSON values).

5) Unsafe pickle cache loading from writable log directory (Potential)
Category: Insecure deserialization
Severity: Medium (Potential)
Location: /home/shiqiu/gpt_academic-3.91/multi_language.py:107-121
Snippet:
    if cache_path is not None and os.path.exists(cache_path):
        with open(cache_path, "rb") as f:
            cache = pickle.load(f)
Attack scenario:
- If an attacker can write a malicious pickle into PATH_LOGGING (CACHE_FOLDER), the next run will unpickle it and execute code.
Impact:
- Arbitrary code execution on startup or cache use.
Preconditions:
- Attacker can write to PATH_LOGGING (e.g., via another file write bug, compromised user, or overly permissive permissions).
Remediation (preferred):
- Store cache in JSON or shelve using safe formats; validate schema.
Defense-in-depth:
- Restrict PATH_LOGGING permissions to the service user only; avoid loading caches from untrusted locations.
Secure-by-default alternatives:
- Use sqlite with parameterized writes/reads for cache storage.

Notes on Non-Findings / Reviewed Areas
- Tar extraction uses a path traversal check before extractall (handle_upload.py:108-117) â€” good.
- Zip extraction uses a custom extractor that strips .. and absolute components (handle_upload.py:45-88), reducing traversal risk.
- File access validation for user-owned paths exists in validate_path_safety (shared_utils/fastapi_server.py:50-69), though it is not enforced in all request paths.

End of report.
